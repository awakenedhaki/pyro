{
  "0-dna": {
    "id": "dna",
    "title": "Counting DNA Nucleotides",
    "statement": "A string is simply an ordered collection of symbols selected from some alphabet and formed into a word; the length of a string is the number of symbols that it contains. An example of a length 21 DNA string (whose alphabet contains the symbols 'A', 'C', 'G', and 'T') is \"ATGCTTCAGAAAGGTCTTACG.\"",
    "given": "Given: A DNA string $s$ of length at most 1000 nt.",
    "return_": "Return: Four integers (separated by spaces) counting the respective number of times that the\nsymbols 'A', 'C', 'G', and 'T' occur in $s$.",
    "input_": "AGCTTTTCATTCTGACTGCAACGGGCAATATGTCTCTGTGTGGATTAAAAAAAGAGTGTCTGATAGCAGC\n",
    "output": "20 12 17 21\n",
    "topics": ["String Algorithms"]
  },
  "1-rna": {
    "id": "rna",
    "title": "Transcribing DNA into RNA",
    "statement": "An RNA string is a string formed from the alphabet containing 'A', 'C', 'G', and 'U'. Given a DNA string $t$ corresponding to a coding strand, its transcribed RNA string $u$ is formed by replacing all occurrences of 'T' in $t$ with 'U' in $u$.",
    "given": "Given: A DNA string $t$ having length at most 1000 nt.",
    "return_": "Return: The transcribed RNA string of $t$.",
    "input_": "GATGGAACTTGACTACGTAAATT\n",
    "output": "GAUGGAACUUGACUACGUAAAUU\n",
    "topics": ["String Algorithms"]
  },
  "2-revc": {
    "id": "revc",
    "title": "Complementing a Strand of DNA",
    "statement": "In DNA strings, symbols 'A' and 'T' are complements of each other, as are 'C' and 'G'. The reverse complement of a DNA string $s$ is the string $s^{\\textrm{c}}$ formed by reversing the symbols of $s$, then taking the complement of each symbol (e.g., the reverse complement of \"GTCA\" is \"TGAC\").",
    "given": "Given: A DNA string $s$ of length at most 1000 bp.",
    "return_": "Return: The reverse complement $s^{\\textrm{c}}$ of $s$.",
    "input_": "AAAACCCGGT\n",
    "output": "ACCGGGTTTT\n",
    "topics": ["String Algorithms"]
  },
  "3-fib": {
    "id": "fib",
    "title": "Rabbits and Recurrence Relations",
    "statement": "A sequence is an ordered collection of objects (usually numbers), which are allowed to repeat.  Sequences can be finite or infinite. Two examples are the finite sequence $(\\pi, -\\sqrt{2}, 0, \\pi)$ and the infinite sequence of odd numbers $(1, 3, 5, 7, 9, \\ldots)$.  We use the notation $a_n$ to represent the $n$-th term of a sequence. A recurrence relation is a way of defining the terms of a sequence with respect to the values of previous terms.  In the case of Fibonacci's rabbits from the introduction, any given month will contain the rabbits that were alive the previous month, plus any new offspring. A key observation is that the number of offspring in any month is equal to the number of rabbits that were alive two months prior.  As a result, if $F_n$ represents the number of rabbit pairs alive after the $n$-th month, then we obtain the Fibonacci sequence having terms $F_n$ that are defined by the recurrence relation $F_{n} = F_{n-1} + F_{n-2}$ (with $F_1 = F_2 = 1$ to initiate the sequence).  Although the sequence bears Fibonacci's name, it was known to Indian mathematicians over two millennia ago. When finding the $n$-th term of a sequence defined by a recurrence relation, we can simply use the recurrence relation to generate terms for progressively larger values of $n$. This problem introduces us to the computational technique of dynamic programming, which successively builds up solutions by using the answers to smaller cases.",
    "given": "Given: Positive integers $n \\leq 40$ and $k \\leq 5$.",
    "return_": "Return: The total number of rabbit pairs that will be present after $n$ months, if we begin with 1 pair and in each generation,\nevery pair of reproduction-age rabbits produces a litter of $k$ rabbit pairs (instead of only 1 pair).",
    "input_": "5 3\n",
    "output": "19\n",
    "topics": ["Combinatorics", "Dynamic Programming"]
  },
  "4-gc": {
    "id": "gc",
    "title": "Computing GC Content",
    "statement": "The GC-content of a DNA string is given by the percentage of symbols in the string that are 'C' or 'G'. For example, the GC-content of \"AGCTATAG\" is 37.5%. Note that the reverse complement of any DNA string has the same GC-content. DNA strings must be labeled when they are consolidated into a database.  A commonly used method of string labeling is called FASTA format.  In this format, the string is introduced by a line that begins with '>', followed by some labeling information. Subsequent lines contain the string itself; the first line to begin with '>' indicates the label of the next string. In Rosalind's implementation, a string in FASTA format will be labeled by the ID \"Rosalind_xxxx\", where \"xxxx\" denotes a four-digit code between 0000 and 9999.",
    "given": "Given: At most 10 DNA strings in FASTA format (of length at most 1 kbp each).",
    "return_": "Return: The ID of the string having the highest GC-content, followed by the GC-content of that string.\nRosalind allows for a default error of 0.001 in all decimal answers unless otherwise\nstated; please see the note on absolute error below.",
    "input_": ">Rosalind_6404\nCCTGCGGAAGATCGGCACTAGAATAGCCAGAACCGTTTCTCTGAGGCTTCCGGCCTTCCC\nTCCCACTAATAATTCTGAGG\n>Rosalind_5959\nCCATCGGTAGCGCATCCTTAGTCCAATTAAGTCCCTATCCAGGCGCTCCGCCGAAGGTCT\nATATCCATTTGTCAGCAGACACGC\n>Rosalind_0808\nCCACCCTCGTGGTATGGCTAGGCATTCAGGAACCGGAGAACGCTTCAGACCAGCCCGGAC\nTGGGAACCTGCGGGCAGTAGGTGGAAT\n",
    "output": "Rosalind_0808\n60.919540\n",
    "topics": ["String Algorithms"]
  },
  "5-hamm": {
    "id": "hamm",
    "title": "Counting Point Mutations",
    "statement": "Given two strings $s$ and $t$ of equal length, the Hamming distance between $s$ and $t$, denoted $d_{\\mathrm{H}}(s, t)$, is the number of corresponding symbols that differ in $s$ and $t$.  See Figure 2.",
    "given": "Given: Two DNA strings $s$ and $t$ of equal length (not exceeding 1 kbp).",
    "return_": "Return: The Hamming distance $d_{\\mathrm{H}}(s, t)$.",
    "input_": "GAGCCTACTAACGGGAT\nCATCGTAATGACGGCCT\n",
    "output": "7\n",
    "topics": ["Alignment"]
  },
  "6-iprb": {
    "id": "iprb",
    "title": "Mendel's First Law",
    "statement": "Probability is the mathematical study of randomly occurring phenomena. We will model such a phenomenon with a random variable, which is simply a variable that can take a number of different distinct outcomes depending on the result of an underlying random process. For example, say that we have a bag containing 3 red balls and 2 blue balls. If we let $X$ represent the random variable corresponding to the color of a drawn ball,  then the probability of each of the two outcomes is given by $\\mathrm{Pr}(X = \\textrm{red}) = \\frac{3}{5}$ and $\\mathrm{Pr}(X = \\textrm{blue}) = \\frac{2}{5}$. Random variables can be combined to yield new random variables.  Returning to the ball example, let $Y$ model the color of a second ball drawn from the bag (without replacing the first ball). The probability of $Y$ being red depends on whether the first ball was red or blue. To represent all outcomes of $X$ and $Y$, we therefore use a probability tree diagram. This branching diagram represents all possible individual probabilities for $X$ and $Y$, with outcomes at the endpoints (\"leaves\") of the tree.  The probability of any outcome is given by the product of probabilities along the path from the beginning of the tree; see Figure 2 for an illustrative example. An event is simply a collection of outcomes.  Because outcomes are distinct, the probability of an event can be written as the sum of the probabilities of its constituent outcomes. For our colored ball example, let $A$ be the event \"$Y$ is blue.\"  $\\mathrm{Pr}(A)$ is equal to the sum of the probabilities of two different outcomes: $\\mathrm{Pr}(X = \\textrm{blue and } Y = \\textrm{blue}) + \\mathrm{Pr}(X = \\textrm{red and } Y = \\textrm{blue})$, or $\\frac{3}{10} + \\frac{1}{10} = \\frac{2}{5}$ (see Figure 2 above).",
    "given": "Given: Three positive integers $k$, $m$, and $n$, representing a population containing $k+m+n$ organisms:\n$k$ individuals are homozygous dominant for a factor, $m$ are heterozygous, and $n$ are homozygous recessive.",
    "return_": "Return: The probability that two randomly selected mating organisms will produce an individual possessing a dominant allele\n(and thus displaying the dominant phenotype). Assume that any two organisms can mate.",
    "input_": "2 2 2\n",
    "output": "0.78333\n",
    "topics": ["Heredity", "Probability"]
  },
  "7-prot": {
    "id": "prot",
    "title": "Translating RNA into Protein",
    "statement": "The 20 commonly occurring amino acids are abbreviated by using 20 letters from the English alphabet (all letters except for B, J, O, U, X, and Z). Protein strings are constructed from these 20 symbols. Henceforth, the term genetic string will incorporate protein strings along with DNA strings and RNA strings. The RNA codon table dictates the details regarding the encoding of specific codons into the amino acid alphabet.",
    "given": "Given: An RNA string $s$ corresponding to a strand of mRNA (of length at most 10 kbp).",
    "return_": "Return: The protein string encoded by $s$.",
    "input_": "AUGGCCAUGGCGCCCAGAACUGAGAUCAAUAGUACCCGUAUUAACGGGUGA\n",
    "output": "MAMAPRTEINSTRING\n",
    "topics": null
  },
  "8-subs": {
    "id": "subs",
    "title": "Finding a Motif in DNA",
    "statement": "Given two strings $s$ and $t$, $t$ is a substring of $s$ if $t$ is contained as a contiguous collection of symbols in $s$ (as a result, $t$ must be no longer than $s$). The position of a symbol in a string is the total number of symbols found to its left, including itself (e.g., the positions of all occurrences of 'U' in \"AUGCUUCAGAAAGGUCUUACG\" are 2, 5, 6, 15, 17, and 18). The symbol at position $i$ of $s$ is denoted by $s[i]$. A substring of $s$ can be represented as $s[j:k]$, where $j$ and $k$ represent the starting and ending positions of the substring in $s$; for example, if $s$ = \"AUGCUUCAGAAAGGUCUUACG\", then $s[2:5]$ = \"UGCU\". The location of a substring $s[j:k]$ is its beginning position $j$; note that $t$ will have multiple locations in $s$ if it occurs more than once as a substring of $s$ (see the Sample below).",
    "given": "Given: Two DNA strings $s$ and $t$ (each of length at most 1 kbp).",
    "return_": "Return: All locations of $t$ as a substring of $s$.",
    "input_": "GATATATGCATATACTT\nATAT\n",
    "output": "2 4 10\n",
    "topics": ["String Algorithms"]
  },
  "9-cons": {
    "id": "cons",
    "title": "Consensus and Profile",
    "statement": "A matrix is a rectangular table of values divided into rows and columns.  An $m \\times n$ matrix has $m$ rows and $n$ columns.  Given a matrix $A$, we write $A_{i, j}$ to indicate the value found at the intersection of row $i$ and column $j$. Say that we have a collection of DNA strings, all having the same length $n$.  Their profile matrix is a $4 \\times n$ matrix $P$ in which $P_{1,j}$ represents the number of times that 'A' occurs in the $j$th position of one of the strings, $P_{2,j}$ represents the number of times that C occurs in the $j$th position, and so on (see below). A consensus string $c$ is a string of length $n$ formed from our collection by taking the most common symbol at each position; the $j$th symbol of $c$ therefore corresponds to the symbol having the maximum value in the $j$-th column of the profile matrix. Of course, there may be more than one most common symbol, leading to multiple possible consensus strings. ",
    "given": "Given: A collection of at most 10 DNA strings of equal length (at most 1 kbp) in FASTA format.",
    "return_": "Return: A consensus string and profile matrix for the collection.\n(If several possible consensus strings exist, then you may return any one of them.)",
    "input_": ">Rosalind_1\nATCCAGCT\n>Rosalind_2\nGGGCAACT\n>Rosalind_3\nATGGATCT\n>Rosalind_4\nAAGCAACC\n>Rosalind_5\nTTGGAACT\n>Rosalind_6\nATGCCATT\n>Rosalind_7\nATGGCACT\n",
    "output": "ATGCAACT\nA: 5 1 0 0 5 5 0 0\nC: 0 0 1 4 2 0 6 1\nG: 1 1 6 3 0 1 0 0\nT: 1 5 0 0 0 1 1 6\n",
    "topics": ["String Algorithms"]
  },
  "10-fibd": {
    "id": "fibd",
    "title": "Mortal Fibonacci Rabbits",
    "statement": "Recall the definition of the Fibonacci numbers from \u201cRabbits and Recurrence Relations\u201d, which followed the recurrence relation $F_n = F_{n-1} + F_{n-2}$ and assumed that each pair of rabbits reaches maturity in one month and produces a single pair of offspring (one male, one female) each subsequent month. Our aim is to somehow modify this recurrence relation to achieve a dynamic programming solution in the case that all rabbits die out after a fixed number of months.  See Figure 4 for a depiction of a rabbit tree in which rabbits live for three months (meaning that they reproduce only twice before dying).",
    "given": "Given: Positive integers $n \\leq 100$ and $m \\leq 20$.",
    "return_": "Return: The total number of pairs of rabbits that will remain after the $n$-th\nmonth if all rabbits live for $m$ months.",
    "input_": "6 3\n",
    "output": "4\n",
    "topics": ["Combinatorics", "Dynamic Programming"]
  },
  "11-grph": {
    "id": "grph",
    "title": "Overlap Graphs",
    "statement": "A graph whose nodes have all been labeled can be represented by an adjacency list, in which each row of the list contains the two node labels corresponding to a unique edge. A directed graph (or digraph) is a graph containing directed edges, each of which has an orientation. That is, a directed edge is represented by an arrow instead of a line segment; the starting and ending nodes of an edge form its tail and head, respectively.  The directed edge with tail $v$ and head $w$ is represented by $(v, w)$ (but not by $(w, v)$).  A directed loop is a directed edge of the form $(v, v)$. For a collection of strings and a positive integer $k$, the overlap graph for the strings is a directed graph $\\mathrm{O}_k$ in which each string is represented by a node, and string $s$ is connected to string $t$ with a directed edge when there is a length $k$ suffix of $s$ that matches a length $k$ prefix of $t$, as long as $s \\neq t$; we demand $s \\neq t$ to prevent directed loops in the overlap graph (although directed cycles may be present).",
    "given": "Given: A collection of DNA strings in FASTA format having total length at most 10 kbp.",
    "return_": "Return: The adjacency list corresponding to $\\mathrm{O}_3$.  You may return edges in any order.",
    "input_": ">Rosalind_0498\nAAATAAA\n>Rosalind_2391\nAAATTTT\n>Rosalind_2323\nTTTTCCC\n>Rosalind_0442\nAAATCCC\n>Rosalind_5013\nGGGTGGG\n",
    "output": "Rosalind_0498 Rosalind_2391\nRosalind_0498 Rosalind_0442\nRosalind_2391 Rosalind_2323\n",
    "topics": ["Graph Algorithms"]
  },
  "12-iev": {
    "id": "iev",
    "title": "Calculating Expected Offspring",
    "statement": "For a random variable $X$ taking integer values between 1 and $n$, the expected value of $X$ is $\\mathrm{E}(X) = \\sum_{k=1}^{n}{k \\times \\mathrm{Pr}(X = k)}$. The expected value offers us a way of taking the long-term average of a random variable over a large number of trials. As a motivating example, let $X$ be the number on a six-sided die.  Over a large number of rolls, we should expect to obtain an average of 3.5 on the die (even though it's not possible to roll a 3.5). The formula for expected value confirms that $\\mathrm{E}(X) = \\sum_{k=1}^{6} k \\times \\mathrm{Pr}(X = k) = 3.5$. More generally, a random variable for which every one of a number of equally spaced outcomes has the same probability is called a uniform random variable (in the die example, this \"equal spacing\" is equal to 1). We can generalize our die example to find that if $X$ is a uniform random variable with minimum possible value $a$ and maximum possible value $b$, then $\\mathrm{E}(X) = \\frac{a+b}{2}$. You may also wish to verify that for the dice example, if $Y$ is the random variable associated with the outcome of a second die roll, then $\\mathrm{E}(X+Y) = 7$.",
    "given": "Given: Six nonnegative integers, each of which does not exceed 20,000.\nThe integers correspond to the number of couples in a population possessing each genotype pairing for a given factor.\nIn order, the six given integers represent the number of couples having the following genotypes:",
    "return_": "Return: The expected number of offspring displaying the dominant phenotype in the next\ngeneration, under the assumption that every couple has exactly two offspring.",
    "input_": "1 0 0 1 0 1\n",
    "output": "3.5\n",
    "topics": ["Heredity", "Probability"]
  },
  "13-lcsm": {
    "id": "lcsm",
    "title": "Finding a Shared Motif",
    "statement": "A common substring of a collection of strings is a substring of every member of the collection.  We say that a common substring is a longest common substring if there does not exist a longer common substring.  For example, \"CG\" is a common substring of \"ACGTACGT\" and \"AACCGTATA\", but it is not as long as possible; in this case, \"CGTA\" is a longest common substring of \"ACGTACGT\" and \"AACCGTATA\". Note that the longest common substring is not necessarily unique; for a simple example, \"AA\" and \"CC\" are both longest common substrings of \"AACC\" and \"CCAA\".",
    "given": "Given: A collection of $k$ ($k \\leq 100$) DNA strings of length at most 1 kbp each in\nFASTA format.",
    "return_": "Return: A longest common substring of the collection. (If multiple solutions\nexist, you may return any single solution.)",
    "input_": ">Rosalind_1\nGATTACA\n>Rosalind_2\nTAGACCA\n>Rosalind_3\nATACA\n",
    "output": "AC\n",
    "topics": ["String Algorithms"]
  },
  "14-lia": {
    "id": "lia",
    "title": "Independent Alleles",
    "statement": "Two events $A$ and $B$ are independent if $\\mathrm{Pr}(A \\textrm{ and } B)$ is equal to $\\mathrm{Pr}(A) \\times \\mathrm{Pr}(B)$.  In other words, the events do not influence each other, so that we may simply calculate each of the individual probabilities separately and then multiply. More generally, random variables $X$ and $Y$ are independent if whenever $A$ and $B$ are respective events for $X$ and $Y$, $A$ and $B$ are independent (i.e., $\\mathrm{Pr}(A \\textrm{ and } B) = \\mathrm{Pr}(A) \\times \\mathrm{Pr}(B)$). As an example of how helpful independence can be for calculating probabilities, let $X$ and $Y$ represent the numbers showing on two six-sided dice.  Intuitively, the number of pips showing on one die should not affect the number showing on the other die. If we want to find the probability that $X + Y$ is odd, then we don't need to draw a tree diagram and consider all possibilities. We simply first note that for $X+Y$ to be odd, either $X$ is even and $Y$ is odd or $X$ is odd and $Y$ is even. In terms of probability, $\\mathrm{Pr}(X+Y \\textrm{ is odd}) = \\mathrm{Pr}(X \\textrm{ is even and } Y \\textrm{ is odd}) + \\mathrm{Pr}(X \\textrm{ is odd and } Y \\textrm{ is even})$. Using independence, this becomes $\\left[\\mathrm{Pr}(X \\textrm{ is even}) \\times \\mathrm{Pr}(Y \\textrm{ is odd})\\right] + \\left[\\mathrm{Pr}(X \\textrm{ is odd}) \\times \\mathrm{Pr}(Y \\textrm{ is even})\\right]$, or $\\left(\\frac{1}{2}\\right)^2 + \\left(\\frac{1}{2}\\right)^2 = \\frac{1}{2}$. You can verify this result in Figure 2, which shows all 36 outcomes for rolling two dice.",
    "given": "Given: Two positive integers $k$ ($k \\leq 7$) and $N$ ($N \\leq 2^k$).  In this problem, we begin with Tom, who in the 0th generation\nhas genotype Aa Bb.  Tom has two children in the 1st generation, each of whom has two children, and so on.\nEach organism always mates with an organism having genotype Aa Bb.",
    "return_": "Return: The probability that at least $N$ Aa Bb organisms will belong to the $k$-th generation of Tom's family tree\n(don't count the Aa Bb mates at each level).  Assume that Mendel's second law holds for the factors.",
    "input_": "2 1\n",
    "output": "0.684\n",
    "topics": ["Heredity", "Probability"]
  },
  "15-mprt": {
    "id": "mprt",
    "title": "Finding a Protein Motif",
    "statement": "To allow for the presence of its varying forms, a protein motif is represented by a shorthand as follows: [XY] means \"either X or Y\" and {X} means \"any amino acid except X.\"  For example, the N-glycosylation motif is written as N{P}[ST]{P}. You can see the complete description and features of a particular protein by its access ID \"uniprot_id\" in the UniProt database, by inserting the ID number into Alternatively, you can obtain a protein sequence in FASTA format by following For example, the data for protein B5ZC00 can be found at http://www.uniprot.org/uniprot/B5ZC00.",
    "given": "Given: At most 15 UniProt Protein Database access IDs.",
    "return_": "Return: For each protein possessing the N-glycosylation motif, output its given access ID followed\nby a list of locations in the protein string where the motif can be found.",
    "input_": "A2Z669\nB5ZC00\nP07204_TRBM_HUMAN\nP20840_SAG1_YEAST\n",
    "output": "B5ZC00\n85 118 142 306 395\nP07204_TRBM_HUMAN\n47 115 116 382 409\nP20840_SAG1_YEAST\n79 109 135 248 306 348 364 402 485 501 614\n",
    "topics": ["File Formats", "Proteomics"]
  },
  "16-mrna": {
    "id": "mrna",
    "title": "Inferring mRNA from Protein",
    "statement": "For positive integers $a$ and $n$, $a$ modulo $n$ (written $a\\mod n$ in shorthand) is the remainder when $a$ is divided by $n$.  For example, $29 \\mod 11 = 7$ because $29 = 11 \\times 2 + 7$. Modular arithmetic is the study of addition, subtraction, multiplication, and division with respect to the modulo operation.  We say that $a$ and $b$ are congruent modulo $n$ if $a \\mod n = b \\mod n$; in this case, we use the notation $a \\equiv b \\mod n$. Two useful facts in modular arithmetic are that if $a \\equiv b \\mod n$ and $c \\equiv d \\mod n$, then $a+c \\equiv b+d \\mod n$ and $a \\times c \\equiv b \\times d \\mod n$.  To check your understanding of these rules, you may wish to verify these relationships for $a = 29$, $b = 73$, $c = 10$, $d = 32$, and $n = 11$. As you will see in this exercise, some Rosalind problems will ask for a (very large) integer solution modulo a smaller number to avoid the computational pitfalls that arise with storing such large numbers.",
    "given": "Given: A protein string of length at most 1000 aa.",
    "return_": "Return: The total number of different RNA strings from which the protein could have been translated, modulo 1,000,000.\n(Don't neglect the importance of the stop codon in protein translation.)",
    "input_": "MA\n",
    "output": "12\n",
    "topics": ["Combinatorics"]
  },
  "17-orf": {
    "id": "orf",
    "title": "Open Reading Frames",
    "statement": "Either strand of a DNA double helix can serve as the coding strand for RNA transcription. Hence, a given DNA string implies six total reading frames, or ways in which the same region of DNA can be translated into amino acids: three reading frames result from reading the string itself, whereas three more result from reading its reverse complement. An open reading frame (ORF) is one which starts from the start codon and ends by stop codon, without any other stop codons in between. Thus, a candidate protein string is derived by translating an open reading frame into amino acids until a stop codon is reached.",
    "given": "Given: A DNA string $s$ of length at most 1 kbp in FASTA format.",
    "return_": "Return: Every distinct candidate protein string that can be translated from ORFs of $s$.\nStrings can be returned in any order.",
    "input_": ">Rosalind_99\nAGCCATGTAGCTAACTCAGGTTACATGGGGATGACCCCGCGACTTGGATTAGAGTCTCTTTTGGAATAAGCCTGAATGATCCGAGTAGCATCTCAG\n",
    "output": "MLLGSFRLIPKETLIQVAGSSPCNLS\nM\nMGMTPRLGLESLLE\nMTPRLGLESLLE\n",
    "topics": ["Combinatorics"]
  },
  "18-perm": {
    "id": "perm",
    "title": "Enumerating Gene Orders",
    "statement": "A permutation of length $n$ is an ordering of the positive integers $\\{1, 2, \\ldots, n\\}$. For example, $\\pi = (5, 3, 2, 1, 4)$ is a permutation of length $5$.",
    "given": "Given: A positive integer $n \\leq 7$.",
    "return_": "Return: The total number of permutations of length $n$, followed by a list of all such\npermutations (in any order).",
    "input_": "3\n",
    "output": "6\n1 2 3\n1 3 2\n2 1 3\n2 3 1\n3 1 2\n3 2 1\n",
    "topics": ["Combinatorics", "Genome Rearrangements"]
  },
  "19-prtm": {
    "id": "prtm",
    "title": "Calculating Protein Mass",
    "statement": "In a weighted alphabet, every symbol is assigned a positive real number called a weight. A string formed from a weighted alphabet is called a weighted string, and its weight is equal to the sum of the weights of its symbols. The standard weight assigned to each member of the 20-symbol amino acid alphabet is the monoisotopic mass of the corresponding amino acid.",
    "given": "Given: A protein string $P$ of length at most 1000 aa.",
    "return_": "Return: The total weight of $P$.  Consult the monoisotopic mass table.",
    "input_": "SKADYEK\n",
    "output": "821.392\n",
    "topics": ["Computational Mass Spectrometry"]
  },
  "20-revp": {
    "id": "revp",
    "title": "Locating Restriction Sites",
    "statement": "A DNA string is a reverse palindrome if it is equal to its reverse complement. For instance, GCATGC is a reverse palindrome because its reverse complement is GCATGC. See Figure 2.",
    "given": "Given: A DNA string of length at most 1 kbp in FASTA format.",
    "return_": "Return: The position and length of every reverse palindrome\nin the string having length between 4 and 12.  You may return these pairs in any order.",
    "input_": ">Rosalind_24\nTCAATGCATGCGGGTCTATATGCAT\n",
    "output": "4 6\n5 4\n6 6\n7 4\n17 4\n18 4\n20 6\n21 4\n",
    "topics": ["String Algorithms"]
  },
  "21-splc": {
    "id": "splc",
    "title": "RNA Splicing",
    "statement": "After identifying the exons and introns of an RNA string, we only need to delete the introns and concatenate the exons to form a new string ready for translation.",
    "given": "Given: A DNA string $s$ (of length at most 1 kbp) and a collection of substrings\nof $s$ acting as introns.  All strings are given in FASTA format.",
    "return_": "Return: A protein string resulting from transcribing and translating the exons of $s$.\n(Note: Only one solution will exist for the dataset provided.)",
    "input_": ">Rosalind_10\nATGGTCTACATAGCTGACAAACAGCACGTAGCAATCGGTCGAATCTCGAGAGGCATATGGTCACATGATCGGTCGAGCGTGTTTCAAAGTTTGCGCCTAG\n>Rosalind_12\nATCGGTCGAA\n>Rosalind_15\nATCGGTCGAGCGTGT\n",
    "output": "MVYIADKQHVASREAYGHMFKVCA\n",
    "topics": ["String Algorithms"]
  },
  "22-lexf": {
    "id": "lexf",
    "title": "Enumerating k-mers Lexicographically",
    "statement": "Assume that an alphabet $\\mathscr{A}$ has a predetermined order; that is, we write the alphabet as a permutation $\\mathscr{A} = (a_1, a_2, \\ldots, a_k)$, where $a_1 < a_2 < \\cdots < a_k$. For instance, the English alphabet is organized as $(\\textrm{A}, \\textrm{B}, \\ldots, \\textrm{Z})$. Given two strings $s$ and $t$ having the same length $n$, we say that $s$ precedes $t$ in the lexicographic order (and write $s <_{\\textrm{Lex}} t$) if the first symbol $s[j]$ that doesn't match $t[j]$ satisfies $s_j < t_j$ in $\\mathscr{A}$.",
    "given": "Given: A collection of at most 10 symbols defining an ordered alphabet, and a positive integer $n$ ($n \\leq 10$).",
    "return_": "Return: All strings of length $n$ that can be formed from the alphabet, ordered lexicographically (use the standard order of symbols in the English alphabet).",
    "input_": "A C G T\n2\n",
    "output": "AA\nAC\nAG\nAT\nCA\nCC\nCG\nCT\nGA\nGC\nGG\nGT\nTA\nTC\nTG\nTT\n",
    "topics": ["String Algorithms"]
  },
  "23-lgis": {
    "id": "lgis",
    "title": "Longest Increasing Subsequence",
    "statement": "A subsequence of a permutation is a collection of elements of the permutation in the order that they appear.  For example, (5, 3, 4) is a subsequence of (5, 1, 3, 4, 2). A subsequence is increasing if the elements of the subsequence increase, and decreasing if the elements decrease. For example, given the permutation (8, 2, 1, 6, 5, 7, 4, 3, 9), an increasing subsequence is (2, 6, 7, 9), and a decreasing subsequence is (8, 6, 5, 4, 3).  You may verify that these two subsequences are as long as possible.",
    "given": "Given: A positive integer $n \\leq 10000$ followed by a permutation $\\pi$ of length $n$.",
    "return_": "Return: A longest increasing subsequence of $\\pi$, followed by a longest decreasing subsequence of $\\pi$.",
    "input_": "5\n5 1 4 2 3\n",
    "output": "1 2 3\n5 4 2\n",
    "topics": ["Dynamic Programming", "Genome Rearrangements"]
  },
  "24-long": {
    "id": "long",
    "title": "Genome Assembly as Shortest Superstring",
    "statement": "For a collection of strings, a larger string containing every one of the smaller strings as a substring is called a superstring. By the assumption of parsimony, a shortest possible superstring over a collection of reads serves as a candidate chromosome. Given: At most 50 DNA strings of approximately equal length, not exceeding 1 kbp, in FASTA format (which represent reads deriving from the same strand of a single linear chromosome).",
    "given": "The dataset is guaranteed to satisfy the following condition:\nthere exists a unique way to reconstruct the entire chromosome from these reads by\ngluing together pairs of reads that overlap by more than half their length.",
    "return_": "Return: A shortest superstring containing all the given strings (thus corresponding\nto a reconstructed chromosome).",
    "input_": ">Rosalind_56\nATTAGACCTG\n>Rosalind_57\nCCTGCCGGAA\n>Rosalind_58\nAGACCTGCCG\n>Rosalind_59\nGCCGGAATAC\n",
    "output": "ATTAGACCTGCCGGAATAC\n",
    "topics": ["Genome Assembly"]
  },
  "25-pmch": {
    "id": "pmch",
    "title": "Perfect Matchings and RNA Secondary Structures",
    "statement": "A matching in a graph $\\mathrm{G}$ is a collection of edges of $\\mathrm{G}$ for which no node belongs to more than one edge in the collection. See Figure 2 for examples of matchings. If $G$ contains an even number of nodes (say $2n$), then a matching on $G$ is perfect if it contains $n$ edges, which is clearly the maximum possible.  An example of a graph containing a perfect matching is shown in Figure 3. First, let $K_n$ denote the complete graph on $2n$ labeled nodes, in which every node is connected to every other node with an edge, and let $p_n$ denote the total number of perfect matchings in $K_n$. For a given node $x$, there are $2n - 1$ ways to join $x$ to the other nodes in the graph, after which point we must form a perfect matching on the remaining $2n - 2$ nodes.  This reasoning provides us with the recurrence relation $p_n = (2n - 1)\\cdot p_{n-1}$; using the fact that $p_1$ is 1, this recurrence relation implies the closed equation $p_n = (2n - 1)(2n - 3)(2n - 5)\\cdots (3)(1)$. Given an RNA string $s = s_1 \\ldots s_n$, a bonding graph for $s$ is formed as follows. First, assign each symbol of $s$ to a node, and arrange these nodes in order around a circle, connecting them with edges called adjacency edges. Second, form all possible edges {A, U} and {C, G}, called basepair edges; we will represent basepair edges with dashed edges, as illustrated by the bonding graph in Figure 4. Note that a matching contained in the basepair edges will represent one possibility for base pairing interactions in $s$, as shown in Figure 5. For such a matching to exist, $s$ must have the same number of occurrences of 'A' as 'U' and the same number of occurrences of 'C' as 'G'.",
    "given": "Given: An RNA string $s$ of length at most 80 bp having the same number of occurrences of 'A' as 'U' and the same number\nof occurrences of 'C' as 'G'.",
    "return_": "Return: The total possible number of perfect matchings of basepair edges in the bonding graph of $s$.",
    "input_": ">Rosalind_23\nAGCUAGUCAU\n",
    "output": "12\n",
    "topics": ["Combinatorics", "Dynamic Programming", "String Algorithms"]
  },
  "26-pper": {
    "id": "pper",
    "title": "Partial Permutations",
    "statement": "A partial permutation is an ordering of only $k$ objects taken from a collection containing $n$ objects (i.e., $k \\leq n$). For example, one partial permutation of three of the first eight positive integers is given by $(5, 7, 2)$. The statistic $P(n, k)$ counts the total number of partial permutations of $k$ objects that can be formed from a collection of $n$ objects.  Note that $P(n, n)$ is just the number of permutations of $n$ objects, which we found to be equal to $n! = n (n-1) (n-2) \\cdots (3) (2)$ in \u201cEnumerating Gene Orders\u201d.",
    "given": "Given: Positive integers $n$ and $k$ such that $100 \\geq n > 0$ and $10 \\geq k > 0$.",
    "return_": "Return: The total number of partial permutations $P(n, k)$, modulo 1,000,000.",
    "input_": "21 7\n",
    "output": "51200\n",
    "topics": ["Combinatorics", "Genome Rearrangements"]
  },
  "27-prob": {
    "id": "prob",
    "title": "Introduction to Random Strings",
    "statement": "An array is a structure containing an ordered collection of objects (numbers, strings, other arrays, etc.). We let $A[k]$ denote the $k$-th value in array $A$.  You may like to think of an array as simply a matrix having only one row. A random string is constructed so that the probability of choosing each subsequent symbol is based on a fixed underlying symbol frequency. GC-content offers us natural symbol frequencies for constructing random DNA strings. If the GC-content is $x$, then we set the symbol frequencies of C and G equal to $\\frac{x}{2}$ and the symbol frequencies of A and T equal to $\\frac{1-x}{2}$.  For example, if the GC-content is 40%, then as we construct the string, the next symbol is 'G'/'C' with probability 0.2, and the next symbol is 'A'/'T' with probability 0.3. In practice, many probabilities wind up being very small. In order to work with small probabilities, we may plug them into a function that \"blows them up\" for the sake of comparison. Specifically, the common logarithm of $x$ (defined for $x > 0$ and denoted $\\log_{10}(x)$) is the exponent to which we must raise 10 to obtain $x$. See Figure 1 for a graph of the common logarithm function $y = \\log_{10}(x)$. In this graph, we can see that the logarithm of $x$-values between 0 and 1 always winds up mapping to $y$-values between $-\\infty$ and 0: $x$-values near 0 have logarithms close to $-\\infty$, and $x$-values close to 1 have logarithms close to $0$. Thus, we will select the common logarithm as our function to \"blow up\" small probability values for comparison.",
    "given": "Given: A DNA string $s$ of length at most 100 bp and an array $A$ containing at most 20 numbers between 0 and 1.",
    "return_": "Return: An array $B$ having the same length as $A$ in which $B[k]$\nrepresents the common logarithm of the probability\nthat a random string constructed with the GC-content found in $A[k]$ will match $s$ exactly.",
    "input_": "ACGATACAA\n0.129 0.287 0.423 0.476 0.641 0.742 0.783\n",
    "output": "-5.737 -5.217 -5.263 -5.360 -5.958 -6.628 -7.009\n",
    "topics": ["Probability"]
  },
  "28-sign": {
    "id": "sign",
    "title": "Enumerating Oriented Gene Orderings",
    "statement": "A signed permutation of length $n$ is some ordering of the positive integers $\\{1, 2, \\ldots, n\\}$ in which each integer is then provided with either a positive or negative sign (for the sake of simplicity, we omit the positive sign). For example, $\\pi = (5, -3, -2, 1, 4)$ is a signed permutation of length $5$.",
    "given": "Given: A positive integer $n \\leq 6$.",
    "return_": "Return: The total number of signed permutations of length $n$, followed by a list\nof all such permutations (you may list the signed permutations in any order).",
    "input_": "2\n",
    "output": "8\n-1 -2\n-1 2\n1 -2\n1 2\n-2 -1\n-2 1\n2 -1\n2 1\n",
    "topics": ["Combinatorics", "Genome Rearrangements"]
  },
  "29-sseq": {
    "id": "sseq",
    "title": "Finding a Spliced Motif",
    "statement": "A subsequence of a string is a collection of symbols contained in order (though not necessarily contiguously) in the string (e.g., ACG is a subsequence of TATGCTAAGATC). The indices of a subsequence are the positions in the string at which the symbols of the subsequence appear; thus, the indices of ACG in TATGCTAAGATC can be represented by (2, 5, 9). As a substring can have multiple locations, a subsequence can have multiple collections of indices, and the same index can be reused in more than one appearance of the subsequence; for example, ACG is a subsequence of AACCGGTT in  8 different ways.",
    "given": "Given: Two DNA strings $s$ and $t$ (each of length at most 1 kbp) in FASTA format.",
    "return_": "Return: One collection of indices of $s$ in which the symbols of $t$\nappear as a subsequence of $s$. If multiple solutions exist, you may return any one.",
    "input_": ">Rosalind_14\nACGTACGTGACG\n>Rosalind_18\nGTA\n",
    "output": "3 8 10\n",
    "topics": ["String Algorithms"]
  },
  "30-tran": {
    "id": "tran",
    "title": "Transitions and Transversions",
    "statement": "For DNA strings $s_1$ and $s_2$ having the same length, their transition/transversion ratio $R(s_1, s_2)$ is the ratio of the total number of transitions to the total number of transversions, where symbol substitutions are inferred from mismatched corresponding symbols as when calculating Hamming distance (see \u201cCounting Point Mutations\u201d).",
    "given": "Given: Two DNA strings $s_1$ and $s_2$ of equal length (at most 1 kbp).",
    "return_": "Return: The transition/transversion ratio $R(s_1, s_2)$.",
    "input_": ">Rosalind_0209\nGCAACGCACAACGAAAACCCTTAGGGACTGGATTATTTCGTGATCGTTGTAGTTATTGGA\nAGTACGGGCATCAACCCAGTT\n>Rosalind_2200\nTTATCTGACAAAGAAAGCCGTCAACGGCTGGATAATTTCGCGATCGTGCTGGTTACTGGC\nGGTACGAGTGTTCCTTTGGGT\n",
    "output": "1.21428571429\n",
    "topics": ["Alignment"]
  },
  "31-tree": {
    "id": "tree",
    "title": "Completing a Tree",
    "statement": "An undirected graph is connected if there is a path connecting any two nodes. A tree is a connected (undirected) graph containing no cycles; this definition forces the tree to have a branching structure organized around a central core of nodes, just like its living counterpart. See Figure 2. We have already grown familiar with trees in \u201cMendel's First Law\u201d, where we introduced the probability tree diagram to visualize the outcomes of a random variable. In the creation of a phylogeny, taxa are encoded by the tree's leaves, or nodes having degree 1. A node of a tree having degree larger than 1 is called an internal node.",
    "given": "Given: A positive integer $n$ ($n \\leq 1000$) and an adjacency list corresponding to a graph on $n$ nodes\nthat contains no cycles.",
    "return_": "Return: The minimum number of edges that can be added to the graph to produce a tree.",
    "input_": "10\n1 2\n2 8\n4 10\n5 9\n6 10\n7 9\n",
    "output": "3\n",
    "topics": ["Graph Algorithms", "Phylogeny"]
  },
  "32-cat": {
    "id": "cat",
    "title": "Catalan Numbers and RNA Secondary Structures",
    "statement": "A matching in a graph is noncrossing if none of its edges cross each other.  If we assume that the $n$ nodes of this graph are arranged around a circle, and if we label these nodes with positive integers between 1 and $n$, then a matching is noncrossing as long as there are not edges $\\{i, j\\}$ and $\\{k, l\\}$ such that $i < k < j < l$. A noncrossing matching of basepair edges in the bonding graph corresponding to an RNA string will correspond to a possible secondary structure of the underlying RNA strand that lacks pseudoknots, as shown in Figure 3. In this problem, we will consider counting noncrossing perfect matchings of basepair edges. As a motivating example of how to count noncrossing perfect matchings, let $c_n$ denote the number of noncrossing perfect matchings in the complete graph $K_{2n}$. After setting $c_0 = 1$, we can see that $c_1$ should equal 1 as well. As for the case of a general $n$, say that the nodes of $K_{2n}$ are labeled with the positive integers from 1 to $2n$.  We can join node 1 to any of the remaining $2n - 1$ nodes; yet once we have chosen this node (say $m$), we cannot add another edge to the matching that crosses the edge $\\{1, m\\}$. As a result, we must match all the edges on one side of $\\{1, m\\}$ to each other. This requirement forces $m$ to be even, so that we can write $m = 2k$ for some positive integer $k$. There are $2k - 2$ nodes on one side of $\\{1, m\\}$ and $2n - 2k$ nodes on the other side of $\\{1, m\\}$, so that in turn there will be $c_{k-1} \\cdot c_{n - k}$ different ways of forming a perfect matching on the remaining nodes of $K_{2n}$. If we let $m$ vary over all possible $n - 1$ choices of even numbers between 1 and $2n$, then we obtain the recurrence relation $c_n = \\sum_{k = 1}^{n}{c_{k-1} \\cdot c_{n-k}}$. The resulting numbers $c_n$ counting noncrossing perfect matchings in $K_{2n}$ are called the Catalan numbers, and they appear in a huge number of other settings.  See Figure 4 for an illustration counting the first four Catalan numbers.",
    "given": "Given: An RNA string $s$ having the same number of occurrences of 'A' as 'U' and the same number\nof occurrences of 'C' as 'G'. The length of the string is at most 300 bp.",
    "return_": "Return: The total number of noncrossing perfect matchings of basepair edges in the bonding\ngraph of $s$, modulo 1,000,000.",
    "input_": ">Rosalind_57\nAUAU\n",
    "output": "2\n",
    "topics": ["Combinatorics", "Dynamic Programming", "String Algorithms"]
  },
  "33-corr": {
    "id": "corr",
    "title": "Error Correction in Reads",
    "statement": "As is the case with point mutations, the most common type of sequencing error occurs when a single nucleotide from a read is interpreted incorrectly.",
    "given": "Given: A collection of up to 1000 reads of equal length (at most 50 bp) in FASTA format.\nSome of these reads were generated with a single-nucleotide error.\nFor each read $s$ in the dataset, one of the following applies:",
    "return_": "Return: A list of all corrections in the form \"[old read]->[new read]\".  (Each correction\nmust be a single symbol substitution, and you may return the corrections in any order.)",
    "input_": ">Rosalind_52\nTCATC\n>Rosalind_44\nTTCAT\n>Rosalind_68\nTCATC\n>Rosalind_28\nTGAAA\n>Rosalind_95\nGAGGA\n>Rosalind_66\nTTTCA\n>Rosalind_33\nATCAA\n>Rosalind_21\nTTGAT\n>Rosalind_18\nTTTCC\n",
    "output": "TTCAT->TTGAT\nGAGGA->GATGA\nTTTCC->TTTCA\n",
    "topics": ["Genome Assembly"]
  },
  "34-inod": {
    "id": "inod",
    "title": "Counting Phylogenetic Ancestors",
    "statement": "A binary tree is a tree in which each node has degree equal to at most 3.  The binary tree will be our main tool in the construction of phylogenies. A rooted tree is a tree in which one node (the root) is set aside to serve as the pinnacle of the tree. A standard graph theory exercise is to verify that for any two nodes of a tree, exactly one path connects the nodes. In a rooted tree, every node $v$ will therefore have a single parent, or the unique node $w$ such that the path from $v$ to the root contains $\\{v, w\\}$.  Any other node $x$ adjacent to $v$ is called a child of $v$ because $v$ must be the parent of $x$; note that a node may have multiple children. In other words, a rooted tree possesses an ordered hierarchy from the root down to its leaves, and as a result, we may often view a rooted tree with undirected edges as a directed graph in which each edge is oriented from parent to child.  We should already be familiar with this idea; it's how the Rosalind problem tree works! Even though a binary tree can include nodes having degree 2, an unrooted binary tree is defined more specifically: all internal nodes have degree 3. In turn, a rooted binary tree is such that only the root has degree 2 (all other internal nodes have degree 3).",
    "given": "Given: A positive integer $n$ ($3 \\leq n \\leq 10000$).",
    "return_": "Return: The number of internal nodes of any unrooted binary tree having $n$ leaves.",
    "input_": "4\n",
    "output": "2\n",
    "topics": ["Combinatorics", "Phylogeny"]
  },
  "35-kmer": {
    "id": "kmer",
    "title": "k-Mer Composition",
    "statement": "For a fixed positive integer $k$, order all possible k-mers taken from an underlying alphabet lexicographically. Then the k-mer composition of a string $s$ can be represented by an array $A$ for which $A[m]$ denotes the number of times that the $m$th k-mer (with respect to the lexicographic order) appears in $s$.",
    "given": "Given: A DNA string $s$ in FASTA format (having length at most 100 kbp).",
    "return_": "Return: The 4-mer composition of $s$.",
    "input_": ">Rosalind_6431\nCTTCGAAAGTTTGGGCCGAGTCTTACAGTCGGTCTTGAAGCAAAGTAACGAACTCCACGG\nCCCTGACTACCGAACCAGTTGTGAGTACTCAACTGGGTGAGAGTGCAGTCCCTATTGAGT\nTTCCGAGACTCACCGGGATTTTCGATCCAGCCTCAGTCCAGTCTTGTGGCCAACTCACCA\nAATGACGTTGGAATATCCCTGTCTAGCTCACGCAGTACTTAGTAAGAGGTCGCTGCAGCG\nGGGCAAGGAGATCGGAAAATGTGCTCTATATGCGACTAAAGCTCCTAACTTACACGTAGA\nCTTGCCCGTGTTAAAAACTCGGCTCACATGCTGTCTGCGGCTGGCTGTATACAGTATCTA\nCCTAATACCCTTCAGTTCGCCGCACAAAAGCTGGGAGTTACCGCGGAAATCACAG\n",
    "output": "4 1 4 3 0 1 1 5 1 3 1 2 2 1 2 0 1 1 3 1 2 1 3 1 1 1 1 2 2 5 1 3 0 2 2 1 1 1 1 3 1 0 0 1 5 5 1 5 0 2 0 2 1 2 1 1 1 2 0 1 0 0 1 1 3 2 1 0 3 2 3 0 0 2 0 8 0 0 1 0 2 1 3 0 0 0 1 4 3 2 1 1 3 1 2 1 3 1 2 1 2 1 1 1 2 3 2 1 1 0 1 1 3 2 1 2 6 2 1 1 1 2 3 3 3 2 3 0 3 2 1 1 0 0 1 4 3 0 1 5 0 2 0 1 2 1 3 0 1 2 2 1 1 0 3 0 0 4 5 0 3 0 2 1 1 3 0 3 2 2 1 1 0 2 1 0 2 2 1 2 0 2 2 5 2 2 1 1 2 1 2 2 2 2 1 1 3 4 0 2 1 1 0 1 2 2 1 1 1 5 2 0 3 2 1 1 2 2 3 0 3 0 1 3 1 2 3 0 2 1 2 2 1 2 3 0 1 2 3 1 1 3 1 0 1 1 3 0 2 1 2 2 0 2 1 1\n",
    "topics": ["String Algorithms"]
  },
  "36-kmp": {
    "id": "kmp",
    "title": "Speeding Up Motif Finding",
    "statement": "A prefix of a length $n$ string $s$ is a substring $s[1:j]$; a suffix of $s$ is a substring $s[k:n]$. The failure array of $s$ is an array $P$ of length $n$ for which $P[k]$ is the length of the longest substring $s[j:k]$ that is equal to some prefix $s[1:k-j+1]$, where $j$ cannot equal $1$ (otherwise, $P[k]$ would always equal $k$). By convention, $P[1] = 0$.",
    "given": "Given: A DNA string $s$ (of length at most 100 kbp) in FASTA format.",
    "return_": "Return: The failure array of $s$.",
    "input_": ">Rosalind_87\nCAGCATGGTATCACAGCAGAG\n",
    "output": "0 0 0 1 2 0 0 0 0 0 0 1 2 1 2 3 4 5 3 0 0\n",
    "topics": ["String Algorithms"]
  },
  "37-lcsq": {
    "id": "lcsq",
    "title": "Finding a Shared Spliced Motif",
    "statement": "A string $u$ is a common subsequence of strings $s$ and $t$ if the symbols of $u$ appear in order as a subsequence of both $s$ and $t$. For example, \"ACTG\" is a common subsequence of \"AACCTTGG\" and \"ACACTGTGA\". Analogously to the definition of longest common substring, $u$ is a longest common subsequence of $s$ and $t$ if there does not exist a longer common subsequence of the two strings.  Continuing our above example, \"ACCTTG\" is a longest common subsequence of \"AACCTTGG\" and \"ACACTGTGA\", as is \"AACTGG\".",
    "given": "Given: Two DNA strings $s$ and $t$ (each having length at most 1 kbp) in FASTA format.",
    "return_": "Return: A longest common subsequence of $s$ and $t$.\n(If more than one solution exists, you may return any one.)",
    "input_": ">Rosalind_23\nAACCTTGG\n>Rosalind_64\nACACTGTGA\n",
    "output": "AACTGG\n",
    "topics": ["Dynamic Programming", "String Algorithms"]
  },
  "38-lexv": {
    "id": "lexv",
    "title": "Ordering Strings of Varying Length Lexicographically",
    "statement": "Say that we have strings $s = s_1 s_2 \\cdots s_m$ and $t = t_1 t_2 \\cdots t_n$ with $m < n$. Consider the substring $t' = t[1:m]$. We have two cases:",
    "given": "Given: A permutation of at most 12 symbols defining an ordered alphabet $\\mathscr{A}$ and a positive integer $n$ ($n \\leq 4$).",
    "return_": "Return: All strings of length at most $n$ formed from $\\mathscr{A}$, ordered lexicographically.\n(Note: As in \u201cEnumerating k-mers Lexicographically\u201d, alphabet order is based on the order in which the symbols are given.)",
    "input_": "D N A\n3\n",
    "output": "D\nDD\nDDD\nDDN\nDDA\nDN\nDND\nDNN\nDNA\nDA\nDAD\nDAN\nDAA\nN\nND\nNDD\nNDN\nNDA\nNN\nNND\nNNN\nNNA\nNA\nNAD\nNAN\nNAA\nA\nAD\nADD\nADN\nADA\nAN\nAND\nANN\nANA\nAA\nAAD\nAAN\nAAA\n",
    "topics": ["String Algorithms"]
  },
  "39-mmch": {
    "id": "mmch",
    "title": "Maximum Matchings and RNA Secondary Structures",
    "statement": "The graph theoretical analogue of the quandary stated in the introduction above is that if we have an RNA string $s$ that does not have the same number of occurrences of 'C' as 'G' and the same number of occurrences of 'A' as 'U', then the bonding graph of $s$ cannot possibly possess a perfect matching among its basepair edges.  For example, see Figure 1; in fact, most bonding graphs will not contain a perfect matching. In light of this fact, we define a maximum matching in a graph as a matching containing as many edges as possible.  See Figure 2 for three maximum matchings in graphs. A maximum matching of basepair edges will correspond to a way of forming as many base pairs as possible in an RNA string, as shown in Figure 3.",
    "given": "Given: An RNA string $s$ of length at most 100.",
    "return_": "Return: The total possible number of maximum matchings of basepair edges in the bonding graph of $s$.",
    "input_": ">Rosalind_92\nAUGCUUC\n",
    "output": "6\n",
    "topics": ["Combinatorics", "Dynamic Programming", "String Algorithms"]
  },
  "40-pdst": {
    "id": "pdst",
    "title": "Creating a Distance Matrix",
    "statement": "For two strings $s_1$ and $s_2$ of equal length, the p-distance between them, denoted $d_p(s_1, s_2)$, is the proportion of corresponding symbols that differ between $s_1$ and $s_2$. For a general distance function $d$ on $n$ taxa $s_1, s_2, \\ldots, s_n$ (taxa are often represented by genetic strings), we may encode the distances between pairs of taxa via a distance matrix $D$ in which $D_{i,j} = d(s_i, s_j)$.",
    "given": "Given: A collection of $n$ ($n \\leq 10$) DNA strings $s_1, \\ldots, s_n$ of equal length (at most 1 kbp).\nStrings are given in FASTA format.",
    "return_": "Return: The matrix $D$ corresponding to the p-distance $d_p$ on the given strings.  As always,\nnote that your answer is allowed an absolute error of 0.001.",
    "input_": ">Rosalind_9499\nTTTCCATTTA\n>Rosalind_0942\nGATTCATTTC\n>Rosalind_6568\nTTTCCATTTT\n>Rosalind_1833\nGTTCCATTTA\n",
    "output": "0.00000 0.40000 0.10000 0.10000\n0.40000 0.00000 0.40000 0.30000\n0.10000 0.40000 0.00000 0.20000\n0.10000 0.30000 0.20000 0.00000\n",
    "topics": ["Alignment", "Phylogeny"]
  },
  "41-rear": {
    "id": "rear",
    "title": "Reversal Distance",
    "statement": "A reversal of a permutation creates a new permutation by inverting some interval of the permutation; $(5, 2, 3, 1, 4)$, $(5, 3, 4, 1, 2)$, and $(4, 1, 2, 3, 5)$ are all reversals of $(5, 3, 2, 1, 4)$. The reversal distance between two permutations $\\pi$ and $\\sigma$, written $d_{\\textrm{rev}}(\\pi, \\sigma)$, is the minimum number of reversals required to transform $\\pi$ into $\\sigma$ (this assumes that $\\pi$ and $\\sigma$ have the same length).",
    "given": "Given: A collection of at most 5 pairs of permutations, all of which have length 10.",
    "return_": "Return: The reversal distance between each permutation pair.",
    "input_": "1 2 3 4 5 6 7 8 9 10\n3 1 5 2 7 4 9 6 10 8\n\n3 10 8 2 5 4 7 1 6 9\n5 2 3 1 7 4 10 8 6 9\n\n8 6 7 9 4 1 3 10 2 5\n8 2 7 6 9 1 5 3 10 4\n\n3 9 10 4 1 8 6 7 5 2\n2 9 8 5 1 7 3 4 6 10\n\n1 2 3 4 5 6 7 8 9 10\n1 2 3 4 5 6 7 8 9 10\n",
    "output": "9 4 5 7 0\n",
    "topics": ["Combinatorics", "Genome Rearrangements"]
  },
  "42-rstr": {
    "id": "rstr",
    "title": "Matching Random Motifs",
    "statement": "Our aim in this problem is to determine the probability with which a given motif (a known promoter, say) occurs in a randomly constructed genome. Unfortunately, finding this probability is tricky; instead of forming a long genome, we will form a large collection of smaller random strings having the same length as the motif; these smaller strings represent the genome's substrings, which we can then test against our motif. Given a probabilistic event $A$, the complement of $A$ is the collection $A^{\\textrm{c}}$ of outcomes not belonging to $A$. Because $A^{\\textrm{c}}$ takes place precisely when $A$ does not, we may also call $A^{\\textrm{c}}$ \"not $A$.\" For a simple example, if $A$ is the event that a rolled die is 2 or 4, then $\\mathrm{Pr}(A) = \\frac{1}{3}$.  $A^{\\textrm{c}}$ is the event that the die is 1, 3, 5, or 6, and $\\mathrm{Pr}(A^{\\textrm{c}}) = \\frac{2}{3}$. In general, for any event we will have the identity that $\\mathrm{Pr(A)} + \\mathrm{Pr}(A^{\\textrm{c}}) = 1$.",
    "given": "Given: A positive integer $N \\leq 100000$, a number $x$ between 0 and 1, and a DNA string $s$ of length at most 10 bp.",
    "return_": "Return: The probability that if $N$ random DNA strings having the same length as $s$\nare constructed with GC-content $x$ (see \u201cIntroduction to Random Strings\u201d), then at least one of the strings equals $s$.\nWe allow for the same random string to be created more than once.",
    "input_": "90000 0.6\nATAGCCGA\n",
    "output": "0.689\n",
    "topics": ["Probability"]
  },
  "43-sset": {
    "id": "sset",
    "title": "Counting Subsets",
    "statement": "A set is the mathematical term for a loose collection of objects, called elements. Examples of sets include $\\{\\textrm{the moon, the sun, Wilford Brimley}\\}$ and $\\mathbb{R}$, the set containing all real numbers. We even have the empty set, represented by $\\emptyset$ or $\\{\\}$, which contains no elements at all. Two sets are equal when they contain the same elements.  In other words, in contrast to permutations, the ordering of the elements of a set is unimportant (e.g., $\\{\\textrm{the moon, the sun, Wilford Brimley}\\}$ is equivalent to $\\{\\textrm{Wilford Brimley, the moon, the sun}\\}$).  Sets are not allowed to contain duplicate elements, so that $\\{\\textrm{Wilford Brimley, the sun, the sun}\\}$ is not a set.  We have already used sets of 2 elements to represent edges from a graph. A set $A$ is a subset of $B$ if every element of $A$ is also an element of $B$, and we write $A \\subseteq B$.  For example, $\\{\\textrm{the sun, the moon}\\} \\subseteq \\{\\textrm{the sun, the moon, Wilford Brimley}\\}$, and $\\emptyset$ is a subset of every set (including itself!). As illustrated in the biological introduction, we can use subsets to represent the collection of taxa possessing a character.  However, the number of applications is endless; for example, an event in probability can now be defined as a subset of the set containing all possible outcomes. Our first question is to count the total number of possible subsets of a given set.",
    "given": "Given: A positive integer $n$ ($n \\leq 1000$).",
    "return_": "Return: The total number of subsets of $\\{1, 2, \\ldots, n\\}$ modulo 1,000,000.",
    "input_": "3\n",
    "output": "8\n",
    "topics": ["Combinatorics", "Set Theory"]
  },
  "44-aspc": {
    "id": "aspc",
    "title": "Introduction to Alternative Splicing",
    "statement": "In \u201cCounting Subsets\u201d, we saw that the total number of subsets of a set $S$ containing $n$ elements is equal to $2^n$. However, if we intend to count the total number of subsets of $S$ having a fixed size $k$, then we use the combination statistic $C(n, k)$, also written $\\binom{n}{k}$.",
    "given": "Given: Positive integers $n$ and $m$ with $0 \\leq m \\leq n \\leq 2000$.",
    "return_": "Return: The sum of combinations $C(n, k)$ for all $k$ satisfying $m \\leq k \\leq n$,\nmodulo 1,000,000.  In shorthand, $\\sum_{k=m}^{n}{\\binom{n}{k}}$.",
    "input_": "6 3\n",
    "output": "42\n",
    "topics": ["Combinatorics"]
  },
  "45-edit": {
    "id": "edit",
    "title": "Edit Distance",
    "statement": "Given two strings $s$ and $t$ (of possibly different lengths), the edit distance $d_{\\textrm{E}}(s, t)$ is the minimum number of edit operations needed to transform $s$ into $t$, where an edit operation is defined as the substitution, insertion, or deletion of a single symbol. The latter two operations incorporate the case in which a contiguous interval is inserted into or deleted from a string; such an interval is called a gap. For the purposes of this problem, the insertion or deletion of a gap of length $k$ still counts as $k$ distinct edit operations.",
    "given": "Given: Two protein strings $s$ and $t$ in FASTA format (each of length at most 1000 aa).",
    "return_": "Return: The edit distance $d_{\\textrm{E}}(s, t)$.",
    "input_": ">Rosalind_39\nPLEASANTLY\n>Rosalind_11\nMEANLY\n",
    "output": "5\n",
    "topics": ["Alignment", "Dynamic Programming"]
  },
  "46-eval": {
    "id": "eval",
    "title": "Expected Number of Restriction Sites",
    "statement": "Say that you place a number of bets on your favorite sports teams.  If their chances of winning are 0.3, 0.8, and 0.6, then you should expect on average to win 0.3 + 0.8 + 0.6 = 1.7 of your bets (of course, you can never win exactly 1.7!) More generally, if we have a collection of events $A_1, A_2, \\ldots, A_n$, then the expected number of events occurring is $\\mathrm{Pr}(A_1) + \\mathrm{Pr}(A_2) + \\cdots + \\mathrm{Pr}(A_n)$ (consult the note following the problem for a precise explanation of this fact). In this problem, we extend the idea of finding an expected number of events to finding the expected number of times that a given string occurs as a substring of a random string.",
    "given": "Given: A positive integer $n$ ($n \\leq 1,000,000$), a DNA string $s$ of even length at most 10,\nand an array $A$ of length at most 20, containing numbers between 0 and 1.",
    "return_": "Return:  An array $B$ having the same length as $A$ in which $B[i]$ represents the expected number of times that $s$\nwill appear as a substring of a random DNA string $t$ of length $n$,\nwhere $t$ is formed with GC-content $A[i]$ (see \u201cIntroduction to Random Strings\u201d).",
    "input_": "10\nAG\n0.25 0.5 0.75\n",
    "output": "0.422 0.563 0.422\n",
    "topics": ["Probability"]
  },
  "47-motz": {
    "id": "motz",
    "title": "Motzkin Numbers and RNA Secondary Structures",
    "statement": "Similarly to our definition of the Catalan numbers, the $n$-th Motzkin number $m_n$ counts the number of ways to form a (not necessarily perfect) noncrossing matching in the complete graph $K_n$ containing $n$ nodes. For example, Figure 1 demonstrates that $m_5 = 21$.  Note in this figure that technically, the \"trivial\" matching that contains no edges at all is considered to be a matching, because it satisfies the defining condition that no two edges are incident to the same node. How should we compute the Motzkin numbers?  As with Catalan numbers, we will take $m_0 = m_1 = 1$. To calculate $m_n$ in general, assume that the nodes of $K_n$ are labeled around the outside of a circle with the integers between 1 and $n$, and consider node 1, which may or may not be involved in a matching. If node 1 is not involved in a matching, then there are $m_{n-1}$ ways of matching the remaining $n - 1$ nodes. If node 1 is involved in a matching, then say it is matched to node $k$: this leaves $k - 2$ nodes on one side of edge $\\{1, k\\}$ and $n - k$ nodes on the other side; as with the Catalan numbers, no edge can connect the two sides, which gives us $m_{k-2} \\cdot m_{n-k}$ ways of matching the remaining edges. Allowing $k$ to vary between $2$ and $n$ yields the following recurrence relation for the Motzkin numbers: $m_n = m_{n-1} + \\sum_{k = 2}^{n}{m_{k-2} \\cdot m_{n-k}}$. To count all possible secondary structures of a given RNA string that do not contain pseudoknots, we need to modify the Motzkin recurrence so that it counts only matchings of basepair edges in the bonding graph corresponding to the RNA string; see Figure 2.",
    "given": "Given: An RNA string $s$ of length at most 300 bp.",
    "return_": "Return: The total number of noncrossing matchings of basepair edges in the bonding graph\nof $s$, modulo 1,000,000.",
    "input_": ">Rosalind_57\nAUAU\n",
    "output": "7\n",
    "topics": ["Combinatorics", "Dynamic Programming", "String Algorithms"]
  },
  "48-nwck": {
    "id": "nwck",
    "title": "Distances in Trees",
    "statement": "Newick format is a way of representing trees even more concisely than using an adjacency list, especially when dealing with trees whose internal nodes have not been labeled. First, consider the case of a rooted tree $T$. A collection of leaves $v_1, v_2, \\ldots, v_n$ of $T$ are neighbors if they are all adjacent to some internal node $u$.  Newick format for $T$ is obtained by iterating the following key step: delete all the edges $\\{v_i, u\\}$ from $T$ and label $u$ with $(v_1, v_2, \\ldots, v_n)u$.  This process is repeated all the way to the root, at which point a semicolon signals the end of the tree. A number of variations of Newick format exist.  First, if a node is not labeled in $T$, then we simply leave blank the space occupied by the node.  In the key step, we can write $(v_1, v_2, \\ldots, v_n)$ in place of $(v_1, v_2, \\ldots, v_n)u$ if the $v_i$ are labeled; if none of the nodes are labeled, we can write $(, , \\ldots, )$. A second variation of Newick format occurs when $T$ is unrooted, in which case we simply select any internal node to serve as the root of $T$.  A particularly peculiar case of Newick format arises when we choose a leaf to serve as the root. Note that there will be a large number of different ways to represent $T$ in Newick format; see Figure 1.",
    "given": "Given: A collection of $n$ trees ($n \\leq 40$) in Newick format, with each tree containing at most 200 nodes;\neach tree $T_k$ is followed by a pair of nodes $x_k$ and $y_k$ in $T_k$.",
    "return_": "Return: A collection of $n$ positive integers, for which the $k$th integer represents the distance\nbetween $x_k$ and $y_k$ in $T_k$.",
    "input_": "(cat)dog;\ndog cat\n\n(dog,cat);\ndog cat\n",
    "output": "1 2\n",
    "topics": ["Phylogeny"]
  },
  "49-scsp": {
    "id": "scsp",
    "title": "Interleaving Two Motifs",
    "statement": "A string $s$ is a supersequence of another string $t$ if $s$ contains $t$ as a subsequence. A common supersequence of strings $s$ and $t$ is a string that serves as a supersequence of both $s$ and $t$.  For example, \"GACCTAGGAACTC\" serves as a common supersequence of \"ACGTC\" and \"ATAT\". A shortest common supersequence of $s$ and $t$ is a supersequence for which there does not exist a shorter common supersequence.  Continuing our example, \"ACGTACT\" is a shortest common supersequence of \"ACGTC\" and \"ATAT\".",
    "given": "Given: Two DNA strings $s$ and $t$.",
    "return_": "Return: A shortest common supersequence of $s$ and $t$.  If multiple solutions exist, you may\noutput any one.",
    "input_": "ATCTGAT\nTGCATA\n",
    "output": "ATGCATGAT\n",
    "topics": ["Dynamic Programming", "String Algorithms"]
  },
  "50-seto": {
    "id": "seto",
    "title": "Introduction to Set Operations",
    "statement": "If $A$ and $B$ are sets, then their union $A \\cup B$ is the set comprising any elements in either $A$ or $B$; their intersection $A \\cap B$ is the set of elements in both $A$ and $B$; and their set difference $A - B$ is the set of elements in $A$ but not in $B$. Furthermore, if $A$ is a subset of another set $U$, then the set complement of $A$ with respect to $U$ is defined as the set $A^{\\textrm{c}} = U - A$.  See the Sample sections below for examples.",
    "given": "Given: A positive integer $n$ ($n \\leq 20,000$) and two subsets $A$ and $B$ of $\\{1, 2, \\ldots, n\\}$.",
    "return_": "Return: Six sets: $A \\cup B$, $A \\cap B$, $A - B$, $B - A$, $A^{\\textrm{c}}$, and $B^{\\textrm{c}}$\n(where set complements are taken with respect to $\\{1, 2, \\ldots, n\\}$).",
    "input_": "10\n{1, 2, 3, 4, 5}\n{2, 8, 5, 10}\n",
    "output": "{1, 2, 3, 4, 5, 8, 10}\n{2, 5}\n{1, 3, 4}\n{8, 10}\n{8, 9, 10, 6, 7}\n{1, 3, 4, 6, 7, 9}\n",
    "topics": ["Set Theory"]
  },
  "51-sort": {
    "id": "sort",
    "title": "Sorting by Reversals",
    "statement": "A reversal of a permutation can be encoded by the two indices at the endpoints of the interval that it inverts; for example, the reversal that transforms $(4, 1, 2, 6, 3, 5)$ into $(4, 1, 3, 6, 2, 5)$ is encoded by $[3, 5]$. A collection of reversals sorts $\\pi$ into $\\gamma$ if the collection contains $d_{\\textrm{rev}}(\\pi, \\gamma)$ reversals, which when successively applied to $\\pi$ yield $\\gamma$.",
    "given": "Given: Two permutations $\\pi$ and $\\gamma$, each of length 10.",
    "return_": "Return: The reversal distance $d_{\\textrm{rev}}(\\pi, \\gamma)$, followed by\na collection of reversals sorting $\\pi$ into $\\gamma$.  If multiple collections of such\nreversals exist, you may return any one.",
    "input_": "1 2 3 4 5 6 7 8 9 10\n1 8 9 3 2 7 6 5 4 10\n",
    "output": "2\n4 9\n2 5\n",
    "topics": ["Combinatorics", "Genome Rearrangements"]
  },
  "52-spec": {
    "id": "spec",
    "title": "Inferring Protein from Spectrum",
    "statement": "The prefix spectrum of a weighted string is the collection of all its prefix weights.",
    "given": "Given: A list $L$ of $n$ ($n \\leq 100$) positive real numbers.",
    "return_": "Return: A protein string of length $n-1$ whose prefix spectrum is equal to $L$\n(if multiple solutions exist, you may output any one of them).  Consult the monoisotopic mass table.",
    "input_": "3524.8542\n3710.9335\n3841.974\n3970.0326\n4057.0646\n",
    "output": "WMQS\n",
    "topics": ["Computational Mass Spectrometry"]
  },
  "53-trie": {
    "id": "trie",
    "title": "Introduction to Pattern Matching",
    "statement": "Given a collection of strings, their trie (often pronounced \"try\" to avoid ambiguity with the general term tree) is a rooted tree formed as follows.  For every unique first symbol in the strings, an edge is formed connecting the root to a new vertex.  This symbol is then used to label the edge. We may then iterate the process by moving down one level as follows.  Say that an edge connecting the root to a node $v$ is labeled with 'A'; then we delete the first symbol from every string in the collection beginning with 'A' and then treat $v$ as our root.  We apply this process to all nodes that are adjacent to the root, and then we move down another level and continue. See Figure 1 for an example of a trie. As a result of this method of construction, the symbols along the edges of any path in the trie from the root to a leaf will spell out a unique string from the collection, as long as no string is a prefix of another in the collection (this would cause the first string to be encoded as a path terminating at an internal node).",
    "given": "Given: A list of at most 100 DNA strings of length at most 100 bp, none of which is a prefix of another.",
    "return_": "Return: The adjacency list corresponding to the trie $T$ for these patterns, in the following format.\nIf $T$ has $n$ nodes, first label the root with 1 and then label the remaining nodes with the integers 2\nthrough $n$ in any order you like.  Each edge of the adjacency list of $T$ will be\nencoded by a triple containing the integer representing the edge's parent node,\nfollowed by the integer representing the edge's child node, and finally the symbol labeling the edge.",
    "input_": "ATAGA\nATC\nGAT\n",
    "output": "1 2 A\n2 3 T\n3 4 A\n4 5 G\n5 6 A\n3 7 C\n1 8 G\n8 9 A\n9 10 T\n",
    "topics": ["Graph Algorithms", "String Algorithms"]
  },
  "54-conv": {
    "id": "conv",
    "title": "Comparing Spectra with the Spectral Convolution",
    "statement": "A multiset is a generalization of the notion of set to include a collection of objects in which each object may occur more than once (the order in which objects are given is still unimportant).  For a multiset $S$, the multiplicity of an element $x$ is the number of times that $x$ occurs in the set; this multiplicity is denoted $S(x)$. Note that every set is included in the definition of multiset. The Minkowski sum of multisets $S_1$ and $S_2$ containing real numbers is the new multiset $S_1 \\oplus S_2$ formed by taking all possible sums $s_1 + s_2$ of an element $s_1$ from $S_1$ and an element $s_2$ from $S_2$. The Minkowski sum could be defined more concisely as $S_1 \\oplus S_2 = {s_1 + s_2 : s_1 \\in S_1, s_2 \\in S_2}$, The Minkowski difference $S_1 \\ominus S_2$ is defined analogously by taking all possible differences $s_1 - s_2$. If $S_1$ and $S_2$ represent simplified spectra taken from two peptides, then $S_1 \\ominus S_2$ is called the spectral convolution of $S_1$ and $S_2$.  In this notation, the shared peaks count is represented by $(S_2 \\ominus S_1)(0)$, and the value of $x$ for which $(S_2 \\ominus S_1)(x)$ has the maximal value is the shift value maximizing the number of shared masses of $S_1$ and $S_2$. Given: Two multisets of positive real numbers $S_1$ and $S_2$. The size of each multiset is at most 200.",
    "given": "Return: The largest multiplicity of $S_1 \\ominus S_2$, as well as the absolute value of the number $x$ maximizing\n$(S_1 \\ominus S_2)(x)$ (you may return any such value if multiple solutions exist).",
    "return_": "Observe that $S_1 \\oplus S_2$ is equivalent to $S_2 \\oplus S_1$, but it is not usually the case that $S_1 \\ominus S_2$\nis the same as $S_2 \\ominus S_1$; in this case, one multiset can be obtained from the other by negating every element.",
    "input_": "186.07931 287.12699 548.20532 580.18077 681.22845 706.27446 782.27613 968.35544 968.35544\n101.04768 158.06914 202.09536 318.09979 419.14747 463.17369\n",
    "output": "3\n85.03163\n",
    "topics": ["Computational Mass Spectrometry"]
  },
  "55-ctbl": {
    "id": "ctbl",
    "title": "Creating a Character Table",
    "statement": "Given a collection of $n$ taxa, any subset $S$ of these taxa can be seen as encoding a character that divides the taxa into the sets $S$ and $S^{\\textrm{c}}$; we can represent the character by $S \\mid S^{\\textrm{c}}$, which is called a split. Alternately, the character can be represented by a character array $A$ of length $n$ for which $A[j] = 1$ if the $j$th taxon belongs to $S$ and $A[j] = 0$ if the $j$th taxon belongs to $S^{\\textrm{c}}$ (recall the \"ON\"/\"OFF\" analogy from \u201cCounting Subsets\u201d). At the same time, observe that the removal of an edge from an unrooted binary tree produces two separate trees, each one containing a subset of the original taxa.  So each edge may also be encoded by a split $S \\mid S^{\\textrm{c}}$. A trivial character isolates a single taxon into a group of its own. The corresponding split $S \\mid S^{\\textrm{c}}$ must be such that $S$ or $S^{\\textrm{c}}$ contains only one element; the edge encoded by this split must be incident to a leaf of the unrooted binary tree, and the array for the character contains exactly one 0 or exactly one 1.  Trivial characters are of no phylogenetic interest because they fail to provide us with information regarding the relationships of taxa to each other. All other characters are called nontrivial characters (and the associated splits are called nontrivial splits). A character table is a matrix $C$ in which each row represents the array notation for a nontrivial character. That is, entry $C_{i,j}$ denotes the \"ON\"/\"OFF\" position of the $i$th character with respect to the $j$th taxon.",
    "given": "Given: An unrooted binary tree $T$ in Newick format for at most 200 species taxa.",
    "return_": "Return: A character table having the same splits as the edge splits of $T$. The columns of the character table\nshould encode the taxa ordered lexicographically; the rows of the character table may be given\nin any order.  Also, for any given character, the particular subset of taxa to which 1s are\nassigned is arbitrary.",
    "input_": "(dog,((elephant,mouse),robot),cat);\n",
    "output": "00110\n00111\n",
    "topics": ["Phylogeny"]
  },
  "56-dbru": {
    "id": "dbru",
    "title": "Constructing a De Bruijn Graph",
    "statement": "Consider a set $S$ of $(k+1)$-mers of some unknown DNA string.  Let $S^{\\textrm{rc}}$ denote the set containing all reverse complements of the elements of $S$. (recall from \u201cCounting Subsets\u201d that sets are not allowed to contain duplicate elements). The de Bruijn graph $B_k$ of order $k$ corresponding to $S \\cup S^{\\textrm{rc}}$ is a digraph defined in the following way:",
    "given": "Given: A collection of up to 1000 (possibly repeating) DNA strings of equal length (not exceeding 50 bp) corresponding to a set $S$ of $(k+1)$-mers.",
    "return_": "Return: The adjacency list corresponding to the de Bruijn graph corresponding to $S \\cup S^{\\textrm{rc}}$.",
    "input_": "TGAT\nCATG\nTCAT\nATGC\nCATC\nCATC\n",
    "output": "(ATC, TCA)\n(ATG, TGA)\n(ATG, TGC)\n(CAT, ATC)\n(CAT, ATG)\n(GAT, ATG)\n(GCA, CAT)\n(TCA, CAT)\n(TGA, GAT)\n",
    "topics": ["Genome Assembly"]
  },
  "57-edta": {
    "id": "edta",
    "title": "Edit Distance Alignment",
    "statement": "An alignment of two strings $s$ and $t$ is defined by two strings $s'$ and $t'$ satisfying the following three conditions: 1. $s'$ and $t'$ must be formed from adding gap symbols \"-\" to each of $s$ and $t$, respectively; as a result, $s$ and $t$ will form subsequences of $s'$ and $t'$. 2. $s'$ and $t'$ must have the same length. 3. Two gap symbols may not be aligned; that is, if $s'[j]$ is a gap symbol, then $t'[j]$ cannot be a gap symbol, and vice-versa. We say that $s'$ and $t'$ augment $s$ and $t$.  Writing $s'$ directly over $t'$ so that symbols are aligned provides us with a scenario for transforming $s$ into $t$. Mismatched symbols from $s$ and $t$ correspond to symbol substitutions; a gap symbol $s'[j]$ aligned with a non-gap symbol $t'[j]$ implies the insertion of this symbol into $t$; a gap symbol $t'[j]$  aligned with a non-gap symbol $s'[j]$ implies the deletion of this symbol from $s$. Thus, an alignment represents a transformation of $s$ into $t$ via edit operations. We define the corresponding edit alignment score of $s'$ and $t'$ as $d_{\\textrm{H}}(s', t')$ (Hamming distance is used because the gap symbol has been introduced for insertions and deletions). It follows that $d_{\\textrm{E}}(s, t) = \\min_{s', t'}{d_{\\textrm{H}}(s', t')}$, where the minimum is taken over all alignments of $s$ and $t$.  We call such a minimum score alignment an optimal alignment (with respect to edit distance).",
    "given": "Given: Two protein strings $s$ and $t$ in FASTA format (with each string having length at most 1000 aa).",
    "return_": "Return: The edit distance $d_{\\textrm{E}}(s, t)$ followed by two augmented strings $s'$ and $t'$\nrepresenting an optimal alignment of $s$ and $t$.",
    "input_": ">Rosalind_43\nPRETTY\n>Rosalind_97\nPRTTEIN\n",
    "output": "4\nPRETTY--\nPR-TTEIN\n",
    "topics": ["Alignment", "Dynamic Programming"]
  },
  "58-full": {
    "id": "full",
    "title": "Inferring Peptide from Full Spectrum",
    "statement": "Say that we have a string $s$ containing $t$ as an internal substring, so that there exist nonempty substrings $s_1$ and $s_2$ of $s$ such that $s$ can be written as $s_1 t s_2$. A t-prefix contains all of $s_1$ and none of $s_2$; likewise, a t-suffix contains all of $s_2$ and none of $s_1$.",
    "given": "Given: A list $L$ containing $2n + 3$ positive real numbers ($n \\leq 100$). The first number in $L$ is the parent mass\nof a peptide $P$, and all other numbers represent the masses of some b-ions and y-ions of $P$ (in no particular order).\nYou may assume that if the mass of a b-ion is present, then so is that of its complementary y-ion, and vice-versa.",
    "return_": "Return: A protein string $t$ of length $n$ for which there exist two positive real numbers $w_1$ and $w_2$\nsuch that for every prefix $p$ and suffix $s$ of $t$, each of $w(p) + w_1$ and $w(s) + w_2$ is\nequal to an element of $L$.  (In other words, there exists a protein string whose $t$-prefix and\n$t$-suffix weights correspond to the non-parent mass values of $L$.)  If multiple solutions exist, you may\noutput any one.",
    "input_": "1988.21104821\n610.391039105\n738.485999105\n766.492149105\n863.544909105\n867.528589105\n992.587499105\n995.623549105\n1120.6824591\n1124.6661391\n1221.7188991\n1249.7250491\n1377.8200091\n",
    "output": "KEKEP\n",
    "topics": ["Computational Mass Spectrometry"]
  },
  "59-indc": {
    "id": "indc",
    "title": "Independent Segregation of Chromosomes",
    "statement": "Consider a collection of coin flips.  One of the most natural questions we can ask is if we flip a coin 92 times, what is the probability of obtaining 51 \"heads\", vs. 27 \"heads\", vs. 92 \"heads\"? Each coin flip can be modeled by a uniform random variable in which each of the two outcomes (\"heads\" and \"tails\") has probability equal to 1/2.  We may assume that these random variables are independent (see \u201cIndependent Alleles\u201d); in layman's terms, the outcomes of the two coin flips do not influence each other. A binomial random variable $X$ takes a value of $k$ if $n$ consecutive \"coin flips\" result in $k$ total \"heads\" and $n-k$ total \"tails.\" We write that $X \\in \\mathrm{Bin}(n, 1/2)$.",
    "given": "Given: A positive integer $n \\leq 50$.",
    "return_": "Return: An array $A$ of length $2n$ in which $A[k]$ represents the common logarithm\nof the probability that two diploid siblings share at least $k$ of their $2n$ chromosomes (we do not consider\nrecombination for now).",
    "input_": "5\n",
    "output": "0.000 -0.004 -0.024 -0.082 -0.206 -0.424 -0.765 -1.262 -1.969 -3.010\n",
    "topics": ["Heredity", "Probability"]
  },
  "60-itwv": {
    "id": "itwv",
    "title": "Finding Disjoint Motifs in a Gene",
    "statement": "Given three strings $s$, $t$, and $u$, we say that $t$ and $u$ can be interwoven into $s$ if there is some substring of $s$ made up of $t$ and $u$ as disjoint subsequences. For example, the strings \"$\\color{blue}\\text{ACAG}$\" and \"$\\color{red}\\text{CCG}$\" can be interwoven into \"$\\color{black}\\text{G}\\color{blue}\\text{A}\\color{red}\\text{C}\\color{blue}\\text{CA}\\color{red}\\text{C}\\color{blue}\\text{G}\\color{red}\\text{G}\\color{black}\\text{TT}$\". However, they cannot be interwoven into \"$\\color{black}\\text{G}\\color{blue}\\text{A}\\color{red}\\text{C}\\color{blue}\\text{CA}\\color{red}\\text{C}\\color{black}\\text{AAAA}\\color{blue}\\text{G}\\color{red}\\text{G}\\color{black}\\text{TT}$\" because of the appearance of the four 'A's in the middle of the subsequences. Similarly, even though both \"$\\textrm{ACACG}$\" is a shortest common supersequence of $\\textrm{ACAG}$ and $\\textrm{CCG}$, it is not possible to interweave these two strings into \"$\\textrm{ACACG}$\" because the two desired subsequences must be disjoint; see \u201cInterleaving Two Motifs\u201d for details on finding a shortest common supersequence of two strings.",
    "given": "Given: A text DNA string $s$ of length at most 10 kbp,\nfollowed by a collection of $n$ ($n \\leq 10$) DNA strings of length at most 10 bp acting as patterns.",
    "return_": "Return: An $n \\times n$ matrix $M$ for which $M_{j, k} = 1$ if the $j$th and $k$th\npattern strings can be interwoven into $s$ and $M_{j, k} = 0$ otherwise.",
    "input_": "GACCACGGTT\nACAG\nGT\nCCG\n",
    "output": "0 0 1\n0 1 0\n1 0 0\n",
    "topics": ["Dynamic Programming", "String Algorithms"]
  },
  "61-lrep": {
    "id": "lrep",
    "title": "Finding the Longest Multiple Repeat",
    "statement": "A repeated substring of a string $s$ of length $n$ is simply a substring that appears in more than one location of $s$; more specifically, a k-fold substring appears in at least k distinct locations. The suffix tree of $s$, denoted $T(s)$, is defined as follows: See Figure 1 for an example of a suffix tree.",
    "given": "Given: A DNA string $s$ (of length at most 20 kbp) with $ appended,\na positive integer $k$, and a list of edges defining the suffix tree of $s$.\nEach edge is represented by four components:",
    "return_": "Return: The longest substring of $s$ that occurs at least $k$ times in $s$. (If multiple solutions\nexist, you may return any single solution.)",
    "input_": "CATACATAC$\n2\nnode1 node2 1 1\nnode1 node7 2 1\nnode1 node14 3 3\nnode1 node17 10 1\nnode2 node3 2 4\nnode2 node6 10 1\nnode3 node4 6 5\nnode3 node5 10 1\nnode7 node8 3 3\nnode7 node11 5 1\nnode8 node9 6 5\nnode8 node10 10 1\nnode11 node12 6 5\nnode11 node13 10 1\nnode14 node15 6 5\nnode14 node16 10 1\n",
    "output": "CATAC\n",
    "topics": ["Graph Algorithms"]
  },
  "62-nkew": {
    "id": "nkew",
    "title": "Newick Format with Edge Weights",
    "statement": "In a weighted tree, each edge is assigned a (usually positive) number, called its weight.  The distance between two nodes in a weighted tree becomes the sum of the weights along the unique path connecting the nodes. To generalize Newick format to the case of a weighted tree $T$, during our repeated \"key step,\" if leaves $v_1, v_2, \\ldots, v_n$ are neighbors in $T$, and all these leaves are incident to $u$, then we replace $u$ with $(v_1:d_1, v_2:d_2, \\ldots, v_n:d_n)u$, where $d_i$ is now the weight on the edge $\\{v_i, u\\}$.",
    "given": "Given: A collection of $n$ weighted trees ($n \\leq 40$) in Newick format, with each tree containing at most 200 nodes;\neach tree $T_k$ is followed by a pair of nodes $x_k$ and $y_k$ in $T_k$.",
    "return_": "Return: A collection of $n$ numbers, for which the $k$th number represents the distance\nbetween $x_k$ and $y_k$ in $T_k$.",
    "input_": "(dog:42,cat:33);\ncat dog\n\n((dog:4,cat:3):74,robot:98,elephant:58);\ndog elephant\n",
    "output": "75 136\n",
    "topics": ["Phylogeny"]
  },
  "63-rnas": {
    "id": "rnas",
    "title": "Wobble Bonding and RNA Secondary Structures",
    "statement": "Given an RNA string $s$, we will augment the bonding graph of $s$ by adding basepair edges connecting all occurrences of 'U' to all occurrences of 'G' in order to represent possible wobble base pairs. We say that a matching in the bonding graph for $s$ is valid if it is noncrossing (to prevent pseudoknots) and has the property that a basepair edge in the matching cannot connect symbols $s_j$ and $s_k$ unless $k \\geq j+4$ (to prevent nearby nucleotides from base pairing). See Figure 1 for an example of a valid matching if we allow wobble base pairs.  In this problem, we will wish to count all possible valid matchings in a given bonding graph; see Figure 2 for all possible valid matchings in a small bonding graph, assuming that we allow wobble base pairing.",
    "given": "Given: An RNA string $s$ (of length at most 200 bp).",
    "return_": "Return: The total number of distinct valid matchings of basepair edges in the bonding graph of $s$.\nAssume that wobble base pairing is allowed.",
    "input_": "AUGCUAGUACGGAGCGAGUCUAGCGAGCGAUGUCGUGAGUACUAUAUAUGCGCAUAAGCCACGU\n",
    "output": "284850219977421\n",
    "topics": ["Combinatorics", "Dynamic Programming", "Graph Algorithms"]
  },
  "64-afrq": {
    "id": "afrq",
    "title": "Counting Disease Carriers",
    "statement": "To model the Hardy-Weinberg principle, assume that we have a population of $N$ diploid individuals. If an allele is in genetic equilibrium, then because mating is random, we may view the $2N$ chromosomes as receiving their alleles uniformly. In other words, if there are $m$ dominant alleles, then the probability of a selected chromosome exhibiting the dominant allele is simply $p = \\frac{m}{2N}$. Because the first assumption of genetic equilibrium states that the population is so large as to be ignored, we will assume that $N$ is infinite, so that we only need to concern ourselves with the value of $p$.",
    "given": "Given: An array $A$ for which $A[k]$ represents the proportion of homozygous recessive\nindividuals for the $k$-th Mendelian factor in a diploid population.\nAssume that the population is in genetic equilibrium for all factors.",
    "return_": "Return: An array $B$ having the same length as $A$ in which $B[k]$ represents the probability\nthat a randomly selected individual carries at least one copy of the recessive allele for the $k$-th factor.",
    "input_": "0.1 0.25 0.5\n",
    "output": "0.532 0.75 0.914\n",
    "topics": ["Population Dynamics", "Probability"]
  },
  "65-cstr": {
    "id": "cstr",
    "title": "Creating a Character Table from Genetic Strings",
    "statement": "A collection of strings is characterizable if there are at most two possible choices for the symbol at each position of the strings.",
    "given": "Given: A collection of at most 100 characterizable DNA strings, each of length at most 300 bp.",
    "return_": "Return: A character table for which each nontrivial character encodes the symbol choice at\na single position of the strings.  (Note: the choice of assigning '1' and '0'\nto the two states of each SNP in the strings is arbitrary.)",
    "input_": "ATGCTACC\nCGTTTACC\nATTCGACC\nAGTCTCCC\nCGTCTATC\n",
    "output": "10110\n10100\n",
    "topics": ["Phylogeny"]
  },
  "66-ctea": {
    "id": "ctea",
    "title": "Counting Optimal Alignments",
    "statement": "Recall from \u201cEdit Distance Alignment\u201d that if $s'$ and $t'$ are the augmented strings corresponding to an alignment of strings $s$ and $t$, then the edit alignment score of $s'$ and $t'$ was given by the Hamming distance $d_{\\textrm{H}}(s', t')$ (because $s'$ and $t'$ have the same length and already include gap symbols to denote insertions/deletions). As a result, we obtain $d_{\\textrm{E}}(s, t) = \\min_{s', t'}{d_{\\textrm{H}}(s', t')}$, where the minimum is taken over all alignments of $s$ and $t$.  Strings $s'$ and $t'$ achieving this minimum correspond to an optimal alignment with respect to edit alignment score.",
    "given": "Given: Two protein strings $s$ and $t$ in FASTA format, each of length at most 1000 aa.",
    "return_": "Return: The total number of optimal alignments of $s$ and $t$ with respect to edit\nalignment score, modulo 134,217,727 (227-1).",
    "input_": ">Rosalind_78\nPLEASANTLY\n>Rosalind_33\nMEANLY\n",
    "output": "4\n",
    "topics": ["Alignment", "Combinatorics"]
  },
  "67-cunr": {
    "id": "cunr",
    "title": "Counting Unrooted Binary Trees",
    "statement": "Two unrooted binary trees $T_1$ and $T_2$ having the same $n$ labeled leaves are considered to be equivalent if there is some assignment of labels to the internal nodes of $T_1$ and $T_2$ so that the adjacency lists of the two trees coincide. As a result, note that $T_1$ and $T_2$ must have the same splits; conversely, if the two trees do not have the same splits, then they are considered distinct. Let $b(n)$ denote the total number of distinct unrooted binary trees having $n$ labeled leaves.",
    "given": "Given: A positive integer $n$ ($n \\leq 1000$).",
    "return_": "Return: The value of $b(n)$ modulo 1,000,000.",
    "input_": "5\n",
    "output": "15\n",
    "topics": ["Combinatorics", "Phylogeny"]
  },
  "68-glob": {
    "id": "glob",
    "title": "Global Alignment with Scoring Matrix",
    "statement": "To penalize symbol substitutions differently depending on which two symbols are involved in the substitution, we obtain a scoring matrix $S$ in which $S_{i, j}$ represents the (negative) score assigned to a substitution of the $i$th symbol of our alphabet $\\mathscr{A}$ with the $j$th symbol of $\\mathscr{A}$. A gap penalty is the component deducted from alignment score due to the presence of a gap. A gap penalty may be a function of the length of the gap; for example, a linear gap penalty is a constant $g$ such that each inserted or deleted symbol is charged $g$; as a result, the cost of a gap of length $L$ is equal to $gL$.",
    "given": "Given: Two protein strings $s$ and $t$ in FASTA format (each of length at most 1000 aa).",
    "return_": "Return: The maximum alignment score between $s$ and $t$. Use:",
    "input_": ">Rosalind_67\nPLEASANTLY\n>Rosalind_17\nMEANLY\n",
    "output": "8\n",
    "topics": ["Alignment", "Dynamic Programming"]
  },
  "69-pcov": {
    "id": "pcov",
    "title": "Genome Assembly with Perfect Coverage",
    "statement": "A circular string is a string that does not have an initial or terminal element; instead, the string is viewed as a necklace of symbols.  We can represent a circular string as a string enclosed in parentheses.  For example, consider the circular DNA string (ACGTAC), and note that because the string \"wraps around\" at the end, this circular string can equally be represented by (CGTACA), (GTACAC), (TACACG), (ACACGT), and (CACGTA).  The definitions of substrings and superstrings are easy to generalize to the case of circular strings (keeping in mind that substrings are allowed to wrap around).",
    "given": "Given: A collection of (error-free) DNA $k$-mers ($k \\leq 50$)\ntaken from the same strand of a circular chromosome. In this dataset, all $k$-mers\nfrom this strand of the chromosome are present, and their de Bruijn graph consists of exactly one simple cycle.",
    "return_": "Return: A cyclic superstring of minimal length containing the reads (thus corresponding\nto a candidate cyclic chromosome).",
    "input_": "ATTAC\nTACAG\nGATTA\nACAGA\nCAGAT\nTTACA\nAGATT\n",
    "output": "GATTACA\n",
    "topics": ["Genome Assembly", "Graph Algorithms"]
  },
  "70-prsm": {
    "id": "prsm",
    "title": "Matching a Spectrum to a Protein",
    "statement": "The complete spectrum of a weighted string $s$ is the multiset $S[s]$ containing the weights of every prefix and suffix of $s$.",
    "given": "Given: A positive integer $n$ followed by a collection of $n$ protein strings $s_1$, $s_2$, ..., $s_n$\nand a multiset $R$ of positive numbers (corresponding to the complete spectrum of some unknown protein string).",
    "return_": "Return: The maximum multiplicity of $R \\ominus S[s_k]$ taken over all strings $s_k$,\nfollowed by the string $s_k$ for which this maximum multiplicity occurs\n(you may output any such value if multiple solutions exist).",
    "input_": "4\nGSDMQS\nVWICN\nIASWMQS\nPVSMGAD\n445.17838\n115.02694\n186.07931\n314.13789\n317.1198\n215.09061\n",
    "output": "3\nIASWMQS\n",
    "topics": ["Computational Mass Spectrometry"]
  },
  "71-qrt": {
    "id": "qrt",
    "title": "Quartets",
    "statement": "A partial split of a set $S$ of $n$ taxa models a partial character and is denoted by $A \\mid B$, where $A$ and $B$ are still the two disjoint subsets of taxa divided by the character. Unlike in the case of splits, we do not necessarily require that $A \\cup B = S$; $(A \\cup B)^{\\textrm{c}}$ corresponds to those taxa for which we lack conclusive evidence regarding the character. We can assemble a collection of partial characters into a generalized partial character table $C$ in which the symbol $x$ is placed in $C_{i, j}$ if we do not have conclusive evidence regarding the $j$th taxon with respect to the $i$th partial character. A quartet is a partial split $A \\mid B$ in which both $A$ and $B$ contain precisely two elements. For the sake of simplicity, we often will consider quartets instead of partial characters. We say that a quartet $A \\mid B$ is inferred from a partial split $C \\mid D$ if $A \\subseteq C$ and $B \\subseteq D$ (or equivalently $A \\subseteq D$ and $B \\subseteq C$).  For example, $\\{1, 3\\} \\mid \\{2, 4\\}$  and $\\{3, 5\\} \\mid \\{2, 4\\}$ can be inferred from $\\{1, 3, 5\\} \\mid \\{2, 4\\}$.",
    "given": "Given: A partial character table $C$.",
    "return_": "Return: The collection of all quartets that can be inferred from the splits corresponding to the underlying characters of $C$.",
    "input_": "cat dog elephant ostrich mouse rabbit robot\n01xxx00\nx11xx00\n111x00x\n",
    "output": "{elephant, dog} {rabbit, robot}\n{cat, dog} {mouse, rabbit}\n{mouse, rabbit} {cat, elephant}\n{dog, elephant} {mouse, rabbit}\n",
    "topics": ["Phylogeny"]
  },
  "72-sgra": {
    "id": "sgra",
    "title": "Using the Spectrum Graph to Infer Peptides",
    "statement": "For a weighted alphabet $\\mathscr{A}$ and a collection $L$ of positive real numbers, the spectrum graph of $L$ is a digraph constructed in the following way.  First, create a node for every real number in $L$.  Then, connect a pair of nodes with a directed edge $(u, v)$ if $v > u$ and $v - u$ is equal to the weight of a single symbol in $\\mathscr{A}$.  We may then label the edge with this symbol. In this problem, we say that a weighted string $s = s_1 s_2 \\cdots s_n$ matches $L$ if there is some increasing sequence of positive real numbers $(w_1, w_2, \\ldots, w_{n+1})$ in $L$ such that $w(s_1) = w_2 - w_1$,  $w(s_2) = w_3 - w_2$, ..., and $w(s_n) = w_{n+1} - w_{n}$.",
    "given": "Given: A list $L$ (of length at most 100) containing positive real numbers.",
    "return_": "Return: The longest protein string that matches the spectrum graph of $L$\n(if multiple solutions exist, you may output any one of them).  Consult the monoisotopic mass table.",
    "input_": "3524.8542\n3623.5245\n3710.9335\n3841.974\n3929.00603\n3970.0326\n4026.05879\n4057.0646\n4083.08025\n",
    "output": "WMSPG\n",
    "topics": ["Computational Mass Spectrometry", "Graph Algorithms"]
  },
  "73-suff": {
    "id": "suff",
    "title": "Encoding Suffix Trees",
    "statement": "Given a string $s$ having length $n$, recall that its suffix tree $T(s)$ is defined by the following properties: Figure 1 contains an example of a suffix tree.",
    "given": "Given: A DNA string $s$ of length at most 1kbp.",
    "return_": "Return: The substrings of $s^*$ encoding the edges of the suffix tree for $s$.  You may list these substrings in any order.",
    "input_": "ATAAATG$\n",
    "output": "AAATG$\nG$\nT\nATG$\nTG$\nA\nA\nAAATG$\nG$\nT\nG$\n$\n",
    "topics": ["Graph Algorithms", "String Algorithms"]
  },
  "74-chbp": {
    "id": "chbp",
    "title": "Character-Based Phylogeny",
    "statement": "Because a tree having $n$ nodes has $n-1$ edges (see \u201cCompleting a Tree\u201d), removing a single edge from a tree will produce two smaller, disjoint trees.  Recall from \u201cCreating a Character Table\u201d that for this reason, each edge of an unrooted binary tree corresponds to a split $S \\mid S^{\\textrm{c}}$, where $S$ is a subset of the taxa. A consistent character table is one whose characters' splits do not conflict with the edge splits of some unrooted binary tree $T$ on the $n$ taxa. More precisely, $S_1 \\mid S_1^{\\textrm{c}}$ conflicts with $S_2 \\mid S_2^{\\textrm{c}}$ if all four intersections $S_1 \\cap S_2$, $S_1 \\cap S_2^{\\textrm{c}}$, $S_1^{\\textrm{c}} \\cap S_2$, and $S_1^{\\textrm{c}} \\cap S_2^{\\textrm{c}}$ are nonempty. As a simple example, consider the conflicting splits $\\{a, b\\} \\mid \\{c, d\\}$ and $\\{a, c\\} \\mid \\{b, d\\}$. More generally, given a consistent character table $C$, an unrooted binary tree $T$ \"models\" $C$ if the edge splits of $T$ agree with the splits induced from the characters of $C$.",
    "given": "Given: A list of $n$ species ($n \\leq 80$) and an $n$-column character table $C$ in which\nthe $j$th column denotes the $j$th species.",
    "return_": "Return: An unrooted binary tree in Newick format that models $C$.",
    "input_": "cat dog elephant mouse rabbit rat\n011101\n001101\n001100\n",
    "output": "(dog,(cat,rabbit),(rat,(elephant,mouse)));\n",
    "topics": ["Phylogeny"]
  },
  "75-cntq": {
    "id": "cntq",
    "title": "Counting Quartets",
    "statement": "A quartet $AB \\mid CD$ is consistent with a binary tree $T$ if the quartet can be inferred from one of the splits of $T$ (see \u201cQuartets\u201d for a description of inferring quartets from splits). Let $q(T)$ denote the total number of quartets that are consistent with $T$.",
    "given": "Given: A positive integer $n$ ($4 \\leq n \\leq 5000$), followed by an unrooted binary tree $T$\nin Newick format on $n$ taxa.",
    "return_": "Return: The value of $q(T)$ modulo 1,000,000.",
    "input_": "6\n(lobster,(cat,dog),(caterpillar,(elephant,mouse)));\n",
    "output": "15\n",
    "topics": ["Combinatorics", "Phylogeny"]
  },
  "76-eubt": {
    "id": "eubt",
    "title": "Enumerating Unrooted Binary Trees",
    "statement": "Recall the definition of Newick format from \u201cDistances in Trees\u201d as a way of encoding trees. See Figure 1 for an example of Newick format applied to an unrooted binary tree whose five leaves are labeled (note that the same tree can have multiple Newick representations).",
    "given": "Given: A collection of species names representing $n$ taxa.",
    "return_": "Return: A list containing all unrooted binary trees whose leaves are these $n$ taxa.\nTrees should be given in Newick format, with one tree on each line; the order of the trees is unimportant.",
    "input_": "dog cat mouse elephant\n",
    "output": "(((mouse,cat),elephant))dog;\n(((elephant,mouse),cat))dog;\n(((elephant,cat),mouse))dog;\n",
    "topics": ["Combinatorics", "Phylogeny"]
  },
  "77-gasm": {
    "id": "gasm",
    "title": "Genome Assembly Using Reads",
    "statement": "A directed cycle is simply a cycle in a directed graph in which the head of one edge is equal to the tail of the next (so that every edge in the cycle is traversed in the same direction). For a set of DNA strings $S$ and a positive integer $k$, let $S_k$ denote the collection of all possible $k$-mers of the strings in $S$.",
    "given": "Given: A collection $S$ of (error-free) reads of equal length (not exceeding 50 bp).\nIn this dataset, for some positive integer $k$, the de Bruijn graph $B_k$ on $S_{k+1} \\cup S_{k+1}^{\\textrm{rc}}$ consists of exactly two directed cycles.",
    "return_": "Return: A cyclic superstring of minimal length containing every read or its reverse complement.",
    "input_": "AATCT\nTGTAA\nGATTA\nACAGA\n",
    "output": "GATTACA\n",
    "topics": ["Genome Assembly", "Graph Algorithms"]
  },
  "78-gcon": {
    "id": "gcon",
    "title": "Global Alignment with Constant Gap Penalty",
    "statement": "In a constant gap penalty, every gap receives some predetermined constant penalty, regardless of its length. Thus, the insertion or deletion of 1000 contiguous symbols is penalized equally to that of a single symbol.",
    "given": "Given: Two protein strings $s$ and $t$ in FASTA format (each of length at most 1000 aa).",
    "return_": "Return: The maximum alignment score between $s$ and $t$. Use:",
    "input_": ">Rosalind_79\nPLEASANTLY\n>Rosalind_41\nMEANLY\n",
    "output": "13\n",
    "topics": ["Alignment", "Dynamic Programming"]
  },
  "79-ling": {
    "id": "ling",
    "title": "Linguistic Complexity of a Genome",
    "statement": "Given a length $n$ string $s$ formed over an alphabet $\\mathscr{A}$ of size $a$, let the \"substring count\" $\\textrm{sub}(s)$ denote the total number of distinct substrings of $s$. Furthermore, let the \"maximum substring count\" $m(a, n)$ denote the maximum number of distinct substrings that could appear in a string of length $n$ formed over $\\mathscr{A}$. The linguistic complexity of $s$ (written $\\textrm{lc}(s)$) is equal to $\\frac{\\textrm{sub}(s)}{m(a, n)}$; in other words, $\\textrm{lc}(s)$ represents the percentage of observed substrings of $s$ to the total number that are theoretically possible.  Note that $0 < \\textrm{lc}(s) < 1$, with smaller values of $\\textrm{lc}(s)$ indicating that $s$ is more repetitive. As an example, consider the DNA string ($a = 4$) $s = \\textrm{ATTTGGATT}$.  In the following table, we demonstrate that $\\textrm{lc}(s) = \\frac{35}{40} = 0.875$ by considering the number of observed and possible length $k$ substrings of $s$, which are denoted by $\\textrm{sub}_{k}(s)$ and $m(a, k, n)$, respectively. (Observe that $m(a, n) = \\sum_{k=1}^{n}{m(a,k,n)} = 40$ and $\\textrm{sub}(s)= \\sum_{k=1}^{n}\\textrm{sub}_{k}(s) = 35$.)",
    "given": "",
    "return_": "",
    "input_": "ATTTGGATT\n",
    "output": "0.875\n",
    "topics": ["String Algorithms"]
  },
  "80-loca": {
    "id": "loca",
    "title": "Local Alignment with Scoring Matrix",
    "statement": "A local alignment of two strings $s$ and $t$ is an alignment of substrings $r$ and $u$ of $s$ and $t$, respectively.  Let $\\textrm{opt}(r, u)$ denote the score of an optimal alignment of $r$ and $u$ with respect to some predetermined alignment score.",
    "given": "Given: Two protein strings $s$ and $t$ in FASTA format (each having length at most 1000 aa).",
    "return_": "Return: A maximum alignment score along with substrings $r$ and $u$ of $s$ and $t$,\nrespectively, which produce this maximum alignment score (multiple solutions may exist,\nin which case you may output any one). Use:",
    "input_": ">Rosalind_80\nMEANLYPRTEINSTRING\n>Rosalind_21\nPLEASANTLYEINSTEIN\n",
    "output": "23\nLYPRTEINSTRIN\nLYEINSTEIN\n",
    "topics": ["Alignment", "Dynamic Programming"]
  },
  "81-mend": {
    "id": "mend",
    "title": "Inferring Genotype from a Pedigree",
    "statement": "A rooted binary tree can be used to model the pedigree of an individual. In this case, rather than time progressing from the root to the leaves, the tree is viewed upside down with time progressing from an individual's ancestors (at the leaves) to the individual (at the root). An example of a pedigree for a single factor in which only the genotypes of ancestors are given is shown in Figure 1.",
    "given": "Given: A rooted binary tree $T$ in Newick format encoding an individual's pedigree\nfor a Mendelian factor whose alleles are A (dominant) and a (recessive).",
    "return_": "Return: Three numbers between 0 and 1, corresponding to the respective probabilities that\nthe individual at the root of $T$ will exhibit the \"AA\", \"Aa\" and \"aa\" genotypes.",
    "input_": "((((Aa,aa),(Aa,Aa)),((aa,aa),(aa,AA))),Aa);\n",
    "output": "0.156 0.5 0.344\n",
    "topics": ["Heredity", "Phylogeny", "Probability"]
  },
  "82-mgap": {
    "id": "mgap",
    "title": "Maximizing the Gap Symbols of an Optimal Alignment",
    "statement": "For the computation of an alignment score generalizing the edit alignment score, let $m$ denote the score assigned to matched symbols, $d$ denote the score assigned to mismatched non-gap symbols, and $g$ denote the score assigned a symbol matched to a gap symbol '-' (i.e., $g$ is a linear gap penalty).",
    "given": "Given: Two DNA strings $s$ and $t$ in FASTA format (each of length at most 5000 bp).",
    "return_": "Return: The maximum number of gap symbols that can appear in any maximum score alignment of $s$ and $t$ with\nscore parameters satisfying $m > 0$, $d < 0$, and $g < 0$.",
    "input_": ">Rosalind_92\nAACGTA\n>Rosalind_47\nACACCTA\n",
    "output": "3\n",
    "topics": ["Alignment", "Dynamic Programming"]
  },
  "83-mrep": {
    "id": "mrep",
    "title": "Identifying Maximal Repeats",
    "statement": "A maximal repeat of a string $s$ is a repeated substring $t$ of $s$ having two occurrences $t_1$ and $t_2$ such that $t_1$ and $t_2$ cannot be extended by one symbol in either direction in $s$ and still agree. For example, \"AG\" is a maximal repeat in \"TAGTTAGCGAGA\" because even though the first two occurrences of \"AG\" can be extended left into \"TAG\", the first and third occurrences differ on both sides of the repeat; thus, we conclude that \"AG\" is a maximal repeat. Note that \"TAG\" is also a maximal repeat of \"TAGTTAGCGAGA\", since its only two occurrences do not still match if we extend them in either direction.",
    "given": "Given: A DNA string $s$ of length at most 1 kbp.",
    "return_": "Return: A list containing all maximal repeats of $s$ having length at least 20.",
    "input_": "TAGAGATAGAATGGGTCCAGAGTTTTGTAATTTCCATGGGTCCAGAGTTTTGTAATTTATTATATAGAGATAGAATGGGTCCAGAGTTTTGTAATTTCCATGGGTCCAGAGTTTTGTAATTTAT\n",
    "output": "TAGAGATAGAATGGGTCCAGAGTTTTGTAATTTCCATGGGTCCAGAGTTTTGTAATTTAT\nATGGGTCCAGAGTTTTGTAATTT\n",
    "topics": ["Graph Algorithms", "String Algorithms"]
  },
  "84-mult": {
    "id": "mult",
    "title": "Multiple Alignment",
    "statement": "A multiple alignment of a collection of three or more strings is formed by adding gap symbols to the strings to produce a collection of augmented strings all having the same length. A multiple alignment score is obtained by taking the sum of an alignment score over all possible pairs of augmented strings.  The only difference in scoring the alignment of two strings is that two gap symbols may be aligned for a given pair (requiring us to specify a score for matched gap symbols).",
    "given": "Given: A collection of four DNA strings of length at most 10 bp in FASTA format.",
    "return_": "Return: A multiple alignment of the strings having maximum score, where we score matched symbols 0\n(including matched gap symbols) and all mismatched symbols -1 (thus incorporating a linear gap penalty of 1).",
    "input_": ">Rosalind_7\nATATCCG\n>Rosalind_35\nTCCG\n>Rosalind_23\nATGTACTG\n>Rosalind_44\nATGTCTG\n",
    "output": "-18\nATAT-CCG\n-T---CCG\nATGTACTG\nATGT-CTG\n",
    "topics": ["Alignment", "Dynamic Programming"]
  },
  "85-pdpl": {
    "id": "pdpl",
    "title": "Creating a Restriction Map",
    "statement": "For a set $X$ containing numbers, the difference multiset of $X$ is the multiset $\\Delta X$ defined as the collection of all positive differences between elements of $X$. As a quick example, if $X =\\{2, 4, 7\\}$, then we will have that $\\Delta X = \\{2, 3, 5\\}$. If $X$ contains $n$ elements, then $\\Delta X$ will contain one element for each pair of elements from $X$, so that $\\Delta X$ contains $\\binom{n}{2}$ elements (see combination statistic). You may note the similarity between the difference multiset and the Minkowski difference $X \\ominus X$, which contains the elements of $\\Delta X$ and their negatives. For the above set $X$, $X \\ominus X$ is $\\{-5, -3, -2, 2, 3, 5\\}$. In practical terms, we can easily obtain a multiset $L$ corresponding to the distances between restriction sites on a chromosome. If we can find a set $X$ whose difference multiset $\\Delta X$ is equal to $L$, then $X$ will represent possible locations of these restriction sites.  For an example, consult Figure 1.",
    "given": "Given: A multiset $L$ containing $\\binom{n}{2}$ positive integers for some positive integer $n$.",
    "return_": "Return: A set $X$ containing $n$ nonnegative integers such that $\\Delta X = L$.",
    "input_": "2 2 3 3 4 5 6 7 8 10\n",
    "output": "0 2 4 7 10\n",
    "topics": ["Set Theory"]
  },
  "86-root": {
    "id": "root",
    "title": "Counting Rooted Binary Trees",
    "statement": "As in the case of unrooted trees, say that we have a fixed collection of $n$ taxa labeling the leaves of a rooted binary tree $T$.  You may like to verify that (by extension of \u201cCounting Phylogenetic Ancestors\u201d) such a tree will contain $n-1$ internal nodes and $2n-2$ total edges. Any edge will still encode a split of taxa; however, the two splits corresponding to the edges incident to the root of $T$ will be equal. We still consider two trees to be equivalent if they have the same splits (which requires that they must also share the same duplicated split to be equal). Let $B(n)$ represent the total number of distinct rooted binary trees on $n$ labeled taxa.",
    "given": "Given: A positive integer $n$ ($n \\leq 1000$).",
    "return_": "Return: The value of $B(n)$ modulo 1,000,000.",
    "input_": "4\n",
    "output": "15\n",
    "topics": ["Combinatorics", "Phylogeny"]
  },
  "87-sexl": {
    "id": "sexl",
    "title": "Sex-Linked Inheritance",
    "statement": "The conditional probability of an event $A$ given another event $B$, written $\\mathrm{Pr}(A \\mid B)$, is equal to $\\mathrm{Pr}(A \\textrm{ and } B)$ divided by $\\mathrm{Pr}(B)$. Note that if $A$ and $B$ are independent, then $\\mathrm{Pr}(A \\textrm{ and } B)$ must be equal to $\\mathrm{Pr}(A) \\times \\mathrm{Pr}(B)$, which results in $\\mathrm{Pr}(A \\mid B) = \\mathrm{Pr}(A)$. This equation offers an intuitive view of independence: the probability of $A$, given the occurrence of event $B$, is simply the probability of $A$ (which does not depend on $B$). In the context of sex-linked traits, genetic equilibrium requires that the alleles for a gene $k$ are uniformly distributed over the males and females of a population. In other words, the distribution of alleles is independent of sex.",
    "given": "Given: An array $A$ of length $n$ for which $A[k]$ represents the proportion of males in a population\nexhibiting the $k$-th of $n$ total recessive X-linked genes. Assume that the population is in genetic equilibrium\nfor all $n$ genes.",
    "return_": "Return: An array $B$ of length $n$ in which $B[k]$ equals the probability\nthat a randomly selected female will be a carrier for the $k$-th gene.",
    "input_": "0.1 0.5 0.8\n",
    "output": "0.18 0.5 0.32\n",
    "topics": ["Heredity", "Probability"]
  },
  "88-sptd": {
    "id": "sptd",
    "title": "Phylogeny Comparison with Split Distance",
    "statement": "Define the split distance between two unrooted binary trees as the number of nontrivial splits contained in one tree but not the other. Formally, if $s(T_1, T_2)$ denotes the number of nontrivial splits shared by unrooted binary trees $T_1$ and $T_2$, Then their split distance is $d_{\\textrm{split}}(T_1, T_2) = 2(n-3) - 2s(T_1, T_2)$.",
    "given": "Given: A collection of at most 3,000 species taxa and two unrooted binary trees $T_1$ and $T_2$\non these taxa in Newick format.",
    "return_": "Return: The split distance $d_{\\textrm{split}}(T_1, T_2)$.",
    "input_": "dog rat elephant mouse cat rabbit\n(rat,(dog,cat),(rabbit,(elephant,mouse)));\n(rat,(cat,dog),(elephant,(mouse,rabbit)));\n",
    "output": "2\n",
    "topics": ["Phylogeny"]
  },
  "89-wfmd": {
    "id": "wfmd",
    "title": "The Wright-Fisher Model of Genetic Drift",
    "statement": "Consider flipping a weighted coin that gives \"heads\" with some fixed probability $p$ (i.e., $p$ is not necessarily equal to 1/2). We generalize the notion of binomial random variable from \u201cIndependent Segregation of Chromosomes\u201d to quantify the sum of the weighted coin flips. Such a random variable $X$ takes a value of $k$ if a sequence of $n$ independent \"weighted coin flips\" yields $k$ \"heads\" and $n-k$ \"tails.\"  We write that $X \\in \\mathrm{Bin}(n, p)$. To quantify the Wright-Fisher Model of genetic drift, consider a population of $N$ diploid individuals, whose $2N$ chromosomes possess $m$ copies of the dominant allele.  As in \u201cCounting Disease Carriers\u201d, set $p = \\frac{m}{2N}$. Next, recall that the next generation must contain exactly $N$ individuals. These individuals' $2N$ alleles are selected independently: a dominant allele is chosen with probability $p$, and a recessive allele is chosen with probability $1-p$.",
    "given": "Given: Positive integers $N$ ($N \\leq 7$), $m$ ($m \\leq 2N$), $g$ ($g \\leq 6$) and $k$ ($k \\leq 2N$).",
    "return_": "Return: The probability that in a population of $N$ diploid individuals initially possessing $m$ copies\nof a dominant allele, we will observe after $g$ generations at least $k$ copies of a recessive allele.\nAssume the Wright-Fisher model.",
    "input_": "4 6 2 1\n",
    "output": "0.772\n",
    "topics": ["Population Dynamics", "Probability"]
  },
  "90-alph": {
    "id": "alph",
    "title": "Alignment-Based Phylogeny",
    "statement": "Say that we have $n$ taxa represented by strings $s_1, s_2, \\ldots, s_n$ with a multiple alignment inducing corresponding augmented strings $\\overline{s}_1, \\overline{s}_2, \\ldots, \\overline{s}_n$. Recall that the number of single-symbol substitutions required to transform one string into another is the Hamming distance between the strings (see \u201cCounting Point Mutations\u201d).  Say that we have a rooted binary tree $T$ containing $\\overline{s}_1, \\overline{s}_2, \\ldots, \\overline{s}_n$ at its leaves and additional strings $\\overline{s}_{n+1}, \\overline{s}_{n+2}, \\ldots, \\overline{s}_{2n-1}$ at its internal nodes, including the root (the number of internal nodes is $n-1$ by extension of \u201cCounting Phylogenetic Ancestors\u201d). Define $d_{\\textrm{H}}(T)$ as the sum of $d_{\\textrm{H}}(\\overline{s}_i, \\overline{s}_j)$ over all edges $\\{\\overline{s}_i, \\overline{s}_j\\}$ in $T$: $d_{\\textrm{H}}(T) = \\sum\\limits_{\\{\\overline{s}_i, \\overline{s}_j\\} \\in E(T)}{d_{\\textrm{H}}(\\overline{s}_i, \\overline{s}_j)}$ Thus, our aim is to minimize $d_{\\textrm{H}}(T)$.",
    "given": "Given: A rooted binary tree $T$ on $n$ ($n \\leq 500$) species, given in Newick format, followed by\na multiple alignment of $m$ ($m \\leq n$) augmented DNA strings having the same length (at most 300 bp)\ncorresponding to the species and given in FASTA format.",
    "return_": "Return: The minimum possible value of $d_{\\textrm{H}}(T)$, followed by a collection of DNA strings\nto be assigned to the internal nodes of $T$ that will minimize $d_{\\textrm{H}}(T)$\n(multiple solutions will exist, but you need only output one).",
    "input_": "(((ostrich,cat)rat,(duck,fly)mouse)dog,(elephant,pikachu)hamster)robot;\n>ostrich\nAC\n>cat\nCA\n>duck\nT-\n>fly\nGC\n>elephant\n-T\n>pikachu\nAA\n",
    "output": "8\n>rat\nAC\n>mouse\nTC\n>dog\nAC\n>hamster\nAT\n>robot\nAC\n",
    "topics": ["Phylogeny"]
  },
  "91-asmq": {
    "id": "asmq",
    "title": "Assessing Assembly Quality with N50 and N75",
    "statement": "Given a collection of DNA strings representing contigs, we use the N statistic NXX (where XX ranges from 01 to 99) to represent the maximum positive integer $L$ such that the total number of nucleotides of all contigs having length $\\ge L$ is at least XX% of the sum of contig lengths.  The most commonly used such statistic is N50, although N75 is also worth mentioning.",
    "given": "Given: A collection of at most 1000 DNA strings\n(whose combined length does not exceed 50 kbp).",
    "return_": "Return: N50 and N75 for this collection of strings.",
    "input_": "GATTACA\nTACTACTAC\nATTGAT\nGAAGA\n",
    "output": "7 6\n",
    "topics": ["Genome Assembly"]
  },
  "92-cset": {
    "id": "cset",
    "title": "Fixing an Inconsistent Character Set",
    "statement": "A submatrix of a matrix $M$ is a matrix formed by selecting rows and columns from $M$ and taking only those entries found at the intersections of the selected rows and columns.  We may also think of a submatrix as formed by deleting the remaining rows and columns from $M$.",
    "given": "Given: An inconsistent character table $C$ on at most 100 taxa.",
    "return_": "Return: A submatrix of $C'$ representing a consistent character table on the same taxa\nand formed by deleting a single row of $C$. (If multiple solutions exist, you may return any one.)",
    "input_": "100001\n000110\n111000\n100111\n",
    "output": "000110\n100001\n100111\n",
    "topics": ["Phylogeny"]
  },
  "93-ebin": {
    "id": "ebin",
    "title": "Wright-Fisher's Expected Behavior",
    "statement": "In \u201cThe Wright-Fisher Model of Genetic Drift\u201d, we generalized the concept of a binomial random variable $\\mathrm{Bin}(n, p)$ as a \"weighted coin flip.\"  It is only natural to calculate the expected value of such a random variable. For example, in the case of unweighted coin flips (i.e., $p = 1/2$), our intuition would indicate that $\\mathrm{E}(\\mathrm{Bin}(n, 1/2))$ is $n/2$; what should be the expected value of a binomial random variable?",
    "given": "Given: A positive integer $n$ ($n \\leq 1000000$) followed by an array $P$ of length\n$m$ ($m \\leq 20$) containing numbers between $0$ and $1$.  Each element of $P$ can be seen\nas representing a probability corresponding to an allele frequency.",
    "return_": "Return: An array $B$ of length $m$ for which $B[k]$ is the expected value of $\\mathrm{Bin}(n, P[k])$;\nin terms of Wright-Fisher, it represents the expected allele frequency of the next generation.",
    "input_": "17\n0.1 0.2 0.3\n",
    "output": "1.7 3.4 5.1\n",
    "topics": ["Probability"]
  },
  "94-foun": {
    "id": "foun",
    "title": "The Founder Effect and Genetic Drift",
    "statement": "",
    "given": "Given: Two positive integers $N$ and $m$, followed by an array $A$ containing $k$ integers between 0 and $2N$.\n$A[j]$ represents the number of recessive alleles for the $j$-th factor in a population of $N$\ndiploid individuals.",
    "return_": "Return: An $m \\times k$ matrix $B$ for which $B_{i, j}$ represents the common logarithm\nof the probability that after $i$ generations, no copies of the recessive allele\nfor the $j$-th factor will remain in the population. Apply the Wright-Fisher model.",
    "input_": "4 3\n0 1 2\n",
    "output": "0.0 -0.463935575821 -0.999509892866\n0.0 -0.301424998891 -0.641668367342\n0.0 -0.229066698008 -0.485798552456\n",
    "topics": ["Population Dynamics", "Probability"]
  },
  "95-gaff": {
    "id": "gaff",
    "title": "Global Alignment with Scoring Matrix and Affine Gap Penalty",
    "statement": "An affine gap penalty is written as $a + b \\cdot (L-1)$, where $L$ is the length of the gap, $a$ is a positive constant called the gap opening penalty, and $b$ is a positive constant called the gap extension penalty. We can view the gap opening penalty as charging for the first gap symbol, and the gap extension penalty as charging for each subsequent symbol added to the gap. For example, if $a = 11$ and $b = 1$, then a gap of length 1 would be penalized by 11 (for an average cost of 11 per gap symbol), whereas a gap of length 100 would have a score of 110 (for an average cost of 1.10 per gap symbol). Consider the strings \"PRTEINS\" and \"PRTWPSEIN\".  If we use the BLOSUM62 scoring matrix and an affine gap penalty with $a = 11$ and $b = 1$, then we obtain the following optimal alignment. Matched symbols contribute a total of 32 to the calculation of the alignment's score, and the gaps cost 13 and 11 respectively, yielding a total score of 8.",
    "given": "Given: Two protein strings $s$ and $t$ in FASTA format (each of length at most 100 aa).",
    "return_": "Return: The maximum alignment score between $s$ and $t$, followed by two augmented strings $s'$ and $t'$\nrepresenting an optimal alignment of $s$ and $t$.  Use:",
    "input_": ">Rosalind_49\nPRTEINS\n>Rosalind_47\nPRTWPSEIN\n",
    "output": "8\nPRT---EINS\nPRTWPSEIN-\n",
    "topics": ["Alignment", "Dynamic Programming"]
  },
  "96-grep": {
    "id": "grep",
    "title": "Genome Assembly with Perfect Coverage and Repeats",
    "statement": "Recall that a directed cycle is a cycle in a directed graph in which the head of one edge is equal to the tail of the following edge. In a de Bruijn graph of $k$-mers, a circular string $s$ is constructed from a directed cycle $s_1 \\rightarrow s_2 \\rightarrow ... \\rightarrow s_i \\rightarrow s_1$ is given by $s_1 + s_2[k] +  ... + s_{i-k}[k]  + s_{i-k+1}[k]$. That is, because the final $k-1$ symbols of $s_1$ overlap with the first $k-1$ symbols of $s_2$, we simply tack on the $k$-th symbol of $s_2$ to $s$, then iterate the process. For example, the circular string assembled from the cycle \"AC\" $\\rightarrow$ \"CT\" $\\rightarrow$ \"TA\" $\\rightarrow$ \"AC\" is simply (ACT).  Note that this string only has length three because the 2-mers \"wrap around\" in the string. If every $k$-mer in a collection of reads occurs as an edge in a de Bruijn graph cycle the same number of times as it appears in the reads, then we say that the cycle is \"complete.\"",
    "given": "Given: A list $S_{k+1}$ of error-free DNA $(k+1)$-mers ($k \\leq 5$) taken from the same strand\nof a circular chromosome (of length $\\leq 50$).",
    "return_": "Return: All circular strings assembled by complete cycles in the de Bruijn graph $B_k$ of $S_{k+1}$.\nThe strings may be given in any order, but each one should begin with the first\n$(k+1)$-mer provided in the input.",
    "input_": "CAG\nAGT\nGTT\nTTT\nTTG\nTGG\nGGC\nGCG\nCGT\nGTT\nTTC\nTCA\nCAA\nAAT\nATT\nTTC\nTCA\n",
    "output": "CAGTTCAATTTGGCGTT\nCAGTTCAATTGGCGTTT\nCAGTTTCAATTGGCGTT\nCAGTTTGGCGTTCAATT\nCAGTTGGCGTTCAATTT\nCAGTTGGCGTTTCAATT\n",
    "topics": ["Genome Assembly", "Graph Algorithms"]
  },
  "97-oap": {
    "id": "oap",
    "title": "Overlap Alignment",
    "statement": "An overlap alignment between two strings $s$ and $t$ is a local alignment of a suffix of $s$ with a prefix of $t$.  An optimal overlap alignment will therefore maximize an alignment score over all such substrings of $s$ and $t$. The term \"overlap alignment\" has also been used to describe what Rosalind defines as a semiglobal alignment.  See \u201cSemiglobal Alignment\u201d for details.",
    "given": "Given: Two DNA strings $s$ and $t$ in FASTA format, each having length at most 10 kbp.",
    "return_": "Return: The score of an optimal overlap alignment of $s$ and $t$, followed by an alignment\nof a suffix $s'$ of $s$ and a prefix $t'$ of $t$ achieving this optimal score.\nUse an alignment score in which matching symbols count +1, substitutions count -2, and\nthere is a linear gap penalty of 2.  If multiple optimal alignments exist, then you may return any one.",
    "input_": ">Rosalind_54\nCTAAGGGATTCCGGTAATTAGACAG\n>Rosalind_45\nATAGACCATATGTCAGTGACTGTGTAA\n",
    "output": "1\nATTAGAC-AG\nAT-AGACCAT\n",
    "topics": ["Alignment", "Dynamic Programming"]
  },
  "98-qrtd": {
    "id": "qrtd",
    "title": "Quartet Distance",
    "statement": "In \u201cCounting Quartets\u201d, we found an expression for $q(T)$, the number of quartets that can be inferred from an unrooted binary tree containing $n$ taxa. If $T_1$ and $T_2$ are both unrooted binary trees on the same $n$ taxa, then we now let $q(T_1, T_2)$ denote the number of inferred quartets that are common to both trees. The quartet distance between $T_1$ and $T_2$, $d_{\\textrm{q}}(T_1, T_2)$ is the number of quartets that are only inferred from one of the trees.  More precisely, $d_\\textrm{q}(T_1, T_2) = q(T_1) + q(T_2) - 2q(T_1, T_2)$.",
    "given": "Given: A list containing $n$ taxa ($n \\leq 2000$) and two unrooted binary trees $T_1$ and $T_2$\non the given taxa.  Both $T_1$ and $T_2$ are given in Newick format.",
    "return_": "Return: The quartet distance $d_\\textrm{q}(T_1, T_2)$.",
    "input_": "A B C D E\n(A,C,((B,D),E));\n(C,(B,D),(A,E));\n",
    "output": "4\n",
    "topics": ["Phylogeny"]
  },
  "99-sims": {
    "id": "sims",
    "title": "Finding a Motif with Modifications",
    "statement": "Given a string $s$ and a motif $t$, an alignment of a substring of $s$ against all of $t$ is called a fitting alignment.  Our aim is to find a substring $s'$ of $s$ that maximizes an alignment score with respect to $t$. Note that more than one such substring of $s$ may exist, depending on the particular strings and alignment score used.  One candidate for scoring function is the one derived from edit distance; In this problem, we will consider a slightly different alignment score, in which all matched symbols count as +1 and all mismatched symbols (including insertions and deletions) receive a cost of -1. Let's call this scoring function the mismatch score. See Figure 1 for a comparison of global, local, and fitting alignments with respect to mismatch score.",
    "given": "Given: Two DNA strings $s$ and $t$, where $s$ has length at most 10 kbp and $t$\nrepresents a motif of length at most 1 kbp.",
    "return_": "Return: An optimal fitting alignment score with respect to the mismatch score defined above,\nfollowed by an optimal fitting alignment of a substring of $s$ against $t$.\nIf multiple such alignments exist, then you may output any one.",
    "input_": ">Rosalind_54\nGCAAACCATAAGCCCTACGTGCCGCCTGTTTAAACTCGCGAACTGAATCTTCTGCTTCACGGTGAAAGTACCACAATGGTATCACACCCCAAGGAAAC\n>Rosalind_46\nGCCGTCAGGCTGGTGTCCG\n",
    "output": "5\nACCATAAGCCCTACGTG-CCG\nGCCGTCAGGC-TG-GTGTCCG\n",
    "topics": null
  },
  "100-smgb": {
    "id": "smgb",
    "title": "Semiglobal Alignment",
    "statement": "A semiglobal alignment of strings $s$ and $t$ is an alignment in which any gaps appearing as prefixes or suffixes of $s$ and $t$ do not contribute to the alignment score. Semiglobal alignment has sometimes also been called \"overlap alignment\".  Rosalind defines overlap alignment differently (see \u201cOverlap Alignment\u201d).",
    "given": "Given: Two DNA strings $s$ and $t$ in FASTA format, each having length at most 10 kbp.",
    "return_": "Return: The maximum semiglobal alignment score of $s$ and $t$, followed by an alignment of $s$\nand $t$ achieving this maximum score.  Use an alignment score in which matching symbols\ncount +1, substitutions count -1, and there is a linear gap penalty of 1.\nIf multiple optimal alignments exist, then you may return any one.",
    "input_": ">Rosalind_79\nCAGCACTTGGATTCTCGG\n>Rosalind_98\nCAGCGTGG\n",
    "output": "4\nCAGCA-CTTGGATTCTCGG\n---CAGCGTGG--------\n",
    "topics": ["Alignment", "Dynamic Programming"]
  },
  "101-ksim": {
    "id": "ksim",
    "title": "Finding All Similar Motifs",
    "statement": "",
    "given": "Given: A positive integer $k$ ($k \\leq 50$), a DNA string $s$ of length at most 5 kbp\nrepresenting a motif, and a DNA string $t$ of length at most 50 kbp representing a genome.",
    "return_": "Return: All substrings $t'$ of $t$ such that the edit distance $d_{\\mathrm{E}}(s, t')$ is\nless than or equal to $k$.  Each substring should be encoded by a pair containing its location\nin $t$ followed by its length.",
    "input_": "2\nACGTAG\nACGGATCGGCATCGT\n",
    "output": "1 4\n1 5\n1 6\n",
    "topics": ["String Algorithms"]
  },
  "102-laff": {
    "id": "laff",
    "title": "Local Alignment with Affine Gap Penalty",
    "statement": "Given: Two protein strings $s$ and $t$ in FASTA format (each having length at most 10,000 aa).",
    "given": "Return: The maximum local alignment score of $s$ and $t$, followed by substrings $r$ and $u$ of $s$ and $t$, respectively,\nthat correspond to the optimal local alignment of $s$ and $t$. Use:",
    "return_": "If multiple solutions exist, then you may output any one.",
    "input_": ">Rosalind_8\nPLEASANTLY\n>Rosalind_18\nMEANLY\n",
    "output": "12\nLEAS\nMEAN\n",
    "topics": ["Alignment", "Dynamic Programming"]
  },
  "103-osym": {
    "id": "osym",
    "title": "Isolating Symbols in Alignments",
    "statement": "Say that we have two strings $s$ and $t$ of respective lengths $m$ and $n$ and an alignment score. Let's define a matrix $\\mathrm{M}$ corresponding to $s$ and $t$ by setting $\\mathrm{M}_{j, k}$ equal to the maximum score of any alignment that aligns $s[j]$ with $t[k]$. So each entry in $\\mathrm{M}$ can be equal to at most the maximum score of any alignment of $s$ and $t$.",
    "given": "Given: Two DNA strings $s$ and $t$ in FASTA format, each having length at most 1000 bp.",
    "return_": "Return: The maximum alignment score of a global alignment of $s$ and $t$, followed by\nthe sum of all elements of the matrix $\\mathrm{M}$ corresponding to $s$ and $t$ that was defined above.  Apply the mismatch score\nintroduced in \u201cFinding a Motif with Modifications\u201d.",
    "input_": ">Rosalind_35\nATAGATA\n>Rosalind_5\nACAGGTA\n",
    "output": "3\n-139\n",
    "topics": ["Alignment", "Dynamic Programming"]
  },
  "104-rsub": {
    "id": "rsub",
    "title": "Identifying Reversing Substitutions",
    "statement": "For a rooted tree $T$ whose internal nodes are labeled with genetic strings, our goal is to identify reversing substitutions in $T$.  Assuming that all the strings of $T$ have the same length, a reversing substitution is defined formally as two parent-child string pairs $(s, t)$ and $(v, w)$ along with a position index $i$, where: In other words, the third condition demands that a reversing substitution must be contiguous: no other substitutions can appear between the initial and reversing substitution.",
    "given": "Given: A rooted binary tree $T$ with labeled nodes in Newick format, followed by a collection\nof at most 100 DNA strings in FASTA format whose labels correspond to the labels of $T$.\nWe will assume that the DNA strings have the same length, which does not exceed 400 bp).",
    "return_": "Return: A list of all reversing substitutions in $T$ (in any order), with each substitution encoded by the following three items:",
    "input_": "(((ostrich,cat)rat,mouse)dog,elephant)robot;\n>robot\nAATTG\n>dog\nGGGCA\n>mouse\nAAGAC\n>rat\nGTTGT\n>cat\nGAGGC\n>ostrich\nGTGTC\n>elephant\nAATTC\n",
    "output": "dog mouse 1 A->G->A\ndog mouse 2 A->G->A\nrat ostrich 3 G->T->G\nrat cat 3 G->T->G\ndog rat 3 T->G->T\n",
    "topics": ["Phylogeny"]
  }
}
