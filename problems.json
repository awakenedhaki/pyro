{
  "('1', 'DNA')": {
    "className": "Problem",
    "moduleName": "model.Problem",
    "num": 1,
    "id": "DNA",
    "title": "Counting DNA Nucleotides",
    "body": "A string is simply an ordered collection of symbols selected from some alphabet and formed into a word; the length of a string is the number of symbols that it contains.\nAn example of a length 21 DNA string (whose alphabet contains the symbols 'A', 'C', 'G', and 'T') is \"ATGCTTCAGAAAGGTCTTACG.\"\nGiven: A DNA string s of length at most 1000 nt.\nReturn: Four integers (separated by spaces) counting the respective number of times that the symbols 'A', 'C', 'G', and 'T' occur in s.\n",
    "data": "AGCTTTTCATTCTGACTGCAACGGGCAATATGTCTCTGTGTGGATTAAAAAAAGAGTGTCTGATAGCAGC",
    "output": "20 12 17 21",
    "topics": "String Algorithms"
  },
  "('2', 'RNA')": {
    "className": "Problem",
    "moduleName": "model.Problem",
    "num": 2,
    "id": "RNA",
    "title": "Transcribing DNA into RNA",
    "body": "An RNA string is a string formed from the alphabet containing 'A', 'C', 'G', and 'U'.\nGiven a DNA string t corresponding to a coding strand, its transcribed RNA string u is formed by replacing all occurrences of 'T' in t with 'U' in u.\nGiven: A DNA string t having length at most 1000 nt.\nReturn: The transcribed RNA string of t.\n",
    "data": "GATGGAACTTGACTACGTAAATT",
    "output": "GAUGGAACUUGACUACGUAAAUU",
    "topics": "String Algorithms"
  },
  "('3', 'REVC')": {
    "className": "Problem",
    "moduleName": "model.Problem",
    "num": 3,
    "id": "REVC",
    "title": "Complementing a Strand of DNA",
    "body": "In DNA strings, symbols 'A' and 'T' are complements of each other, as are 'C' and 'G'.\nThe reverse complement of a DNA string s is the string s^{\\textrm{c}} formed by reversing the symbols of s, then taking the complement of each symbol (e.g., the reverse complement of \"GTCA\" is \"TGAC\").\nGiven: A DNA string s of length at most 1000 bp.\nReturn: The reverse complement s^{\\textrm{c}} of s.\n",
    "data": "AAAACCCGGT",
    "output": "ACCGGGTTTT",
    "topics": "String Algorithms"
  },
  "('4', 'FIB')": {
    "className": "Problem",
    "moduleName": "model.Problem",
    "num": 4,
    "id": "FIB",
    "title": "Rabbits and Recurrence Relations",
    "body": "A sequence is an ordered collection of objects (usually numbers), which are allowed to repeat.  Sequences can be finite or infinite. Two examples are the finite sequence (\\pi, -\\sqrt{2}, 0, \\pi) and the infinite sequence of odd numbers (1, 3, 5, 7, 9, \\ldots).  We use the notation a_n to represent the n-th term of a sequence.\nA recurrence relation is a way of defining the terms of a sequence with respect to the values of previous terms.  In the case of Fibonacci's rabbits from the introduction, any given month will contain the rabbits that were alive the previous month, plus any new offspring. A key observation is that the number of offspring in any month is equal to the number of rabbits that were alive two months prior.  As a result, if F_n represents the number of rabbit pairs alive after the n-th month, then we obtain the Fibonacci sequence having terms F_n that are defined by the recurrence relation F_{n} = F_{n-1} + F_{n-2} (with F_1 = F_2 = 1 to initiate the sequence).  Although the sequence bears Fibonacci's name, it was known to Indian mathematicians over two millennia ago.\nWhen finding the n-th term of a sequence defined by a recurrence relation, we can simply use the recurrence relation to generate terms for progressively larger values of n. This problem introduces us to the computational technique of dynamic programming, which successively builds up solutions by using the answers to smaller cases.\nGiven: Positive integers n \\leq 40 and k \\leq 5.\nReturn: The total number of rabbit pairs that will be present after n months, if we begin with 1 pair and in each generation, every pair of reproduction-age rabbits produces a litter of k rabbit pairs (instead of only 1 pair).\n",
    "data": "5 3",
    "output": "19",
    "topics": "Combinatorics, Dynamic Programming"
  },
  "('5', 'GC')": {
    "className": "Problem",
    "moduleName": "model.Problem",
    "num": 5,
    "id": "GC",
    "title": "Computing GC Content",
    "body": "The GC-content of a DNA string is given by the percentage of symbols in the string that are 'C' or 'G'. For example, the GC-content of \"AGCTATAG\" is 37.5%. Note that the reverse complement of any DNA string has the same GC-content. \nDNA strings must be labeled when they are consolidated into a database.  A commonly used method of string labeling is called FASTA format.  In this format, the string is introduced by a line that begins with '>', followed by some labeling information. Subsequent lines contain the string itself; the first line to begin with '>' indicates the label of the next string.\nIn Rosalind's implementation, a string in FASTA format will be labeled by the ID \"Rosalind_xxxx\", where \"xxxx\" denotes a four-digit code between 0000 and 9999.\nGiven: At most 10 DNA strings in FASTA format (of length at most 1 kbp each).\nReturn: The ID of the string having the highest GC-content, followed by the GC-content of that string. Rosalind allows for a default error of 0.001 in all decimal answers unless otherwise stated; please see the note on absolute error below.\nWe say that a number x is within an absolute error of y to a correct solution if x is within y of the correct solution.  For example, if an exact solution is 6.157892, then for x to be within an absolute error of 0.001, we must have that |x - 6.157892| < 0.001, or 6.156892 < x < 6.158892.\nError bounding is a vital practical tool because of the inherent round-off error in representing decimals in a computer, where only a finite number of decimal places are allotted to any number. After being compounded over a number of operations, this round-off error can become evident. As a result, rather than testing whether two numbers are equal with x = z, you may wish to simply verify that |x- z| is very small.\nThe mathematical field of numerical analysis is devoted to rigorously studying the nature of computational approximation.\n",
    "data": ">Rosalind_6404\nCCTGCGGAAGATCGGCACTAGAATAGCCAGAACCGTTTCTCTGAGGCTTCCGGCCTTCCC\nTCCCACTAATAATTCTGAGG\n>Rosalind_5959\nCCATCGGTAGCGCATCCTTAGTCCAATTAAGTCCCTATCCAGGCGCTCCGCCGAAGGTCT\nATATCCATTTGTCAGCAGACACGC\n>Rosalind_0808\nCCACCCTCGTGGTATGGCTAGGCATTCAGGAACCGGAGAACGCTTCAGACCAGCCCGGAC\nTGGGAACCTGCGGGCAGTAGGTGGAAT",
    "output": "Rosalind_0808\n60.919540",
    "topics": "String Algorithms"
  },
  "('6', 'HAMM')": {
    "className": "Problem",
    "moduleName": "model.Problem",
    "num": 6,
    "id": "HAMM",
    "title": "Counting Point Mutations",
    "body": "Given two strings s and t of equal length, the Hamming distance between s and t, denoted d_{\\mathrm{H}}(s, t), is the number of corresponding symbols that differ in s and t.  See Figure 2.\nGiven: Two DNA strings s and t of equal length (not exceeding 1 kbp).\nReturn: The Hamming distance d_{\\mathrm{H}}(s, t).\n",
    "data": "GAGCCTACTAACGGGAT\nCATCGTAATGACGGCCT",
    "output": "7",
    "topics": "Alignment"
  },
  "('7', 'IPRB')": {
    "className": "Problem",
    "moduleName": "model.Problem",
    "num": 7,
    "id": "IPRB",
    "title": "Mendel's First Law",
    "body": "Probability is the mathematical study of randomly occurring phenomena. We will model such a phenomenon with a random variable, which is simply a variable that can take a number of different distinct outcomes depending on the result of an underlying random process.\nFor example, say that we have a bag containing 3 red balls and 2 blue balls. If we let X represent the random variable corresponding to the color of a drawn ball,  then the probability of each of the two outcomes is given by \\mathrm{Pr}(X = \\textrm{red}) = \\frac{3}{5} and \\mathrm{Pr}(X = \\textrm{blue}) = \\frac{2}{5}.\nRandom variables can be combined to yield new random variables.  Returning to the ball example, let Y model the color of a second ball drawn from the bag (without replacing the first ball). The probability of Y being red depends on whether the first ball was red or blue. To represent all outcomes of X and Y, we therefore use a probability tree diagram. This branching diagram represents all possible individual probabilities for X and Y, with outcomes at the endpoints (\"leaves\") of the tree.  The probability of any outcome is given by the product of probabilities along the path from the beginning of the tree; see Figure 2 for an illustrative example.\nAn event is simply a collection of outcomes.  Because outcomes are distinct, the probability of an event can be written as the sum of the probabilities of its constituent outcomes. For our colored ball example, let A be the event \"Y is blue.\"  \\mathrm{Pr}(A) is equal to the sum of the probabilities of two different outcomes: \\mathrm{Pr}(X = \\textrm{blue and } Y = \\textrm{blue}) + \\mathrm{Pr}(X = \\textrm{red and } Y = \\textrm{blue}), or \\frac{3}{10} + \\frac{1}{10} = \\frac{2}{5} (see Figure 2 above).\nGiven: Three positive integers k, m, and n, representing a population containing k+m+n organisms: k individuals are homozygous dominant for a factor, m are heterozygous, and n are homozygous recessive.\nReturn: The probability that two randomly selected mating organisms will produce an individual possessing a dominant allele (and thus displaying the dominant phenotype). Assume that any two organisms can mate.\nConsider simulating inheritance on a number of small test cases in order to check your solution.\n",
    "data": "2 2 2",
    "output": "0.78333",
    "topics": "Heredity, Probability"
  },
  "('8', 'PROT')": {
    "className": "Problem",
    "moduleName": "model.Problem",
    "num": 8,
    "id": "PROT",
    "title": "Translating RNA into Protein",
    "body": "The 20 commonly occurring amino acids are abbreviated by using 20 letters from the English alphabet (all letters except for B, J, O, U, X, and Z). Protein strings are constructed from these 20 symbols. Henceforth, the term genetic string will incorporate protein strings along with DNA strings and RNA strings.\nThe RNA codon table dictates the details regarding the encoding of specific codons into the amino acid alphabet.\nGiven: An RNA string s corresponding to a strand of mRNA (of length at most 10 kbp).\nReturn: The protein string encoded by s.\n",
    "data": "AUGGCCAUGGCGCCCAGAACUGAGAUCAAUAGUACCCGUAUUAACGGGUGA",
    "output": "MAMAPRTEINSTRING",
    "topics": null
  },
  "('9', 'SUBS')": {
    "className": "Problem",
    "moduleName": "model.Problem",
    "num": 9,
    "id": "SUBS",
    "title": "Finding a Motif in DNA",
    "body": "Given two strings s and t, t is a substring of s if t is contained as a contiguous collection of symbols in s (as a result, t must be no longer than s).\nThe position of a symbol in a string is the total number of symbols found to its left, including itself (e.g., the positions of all occurrences of 'U' in \"AUGCUUCAGAAAGGUCUUACG\" are 2, 5, 6, 15, 17, and 18). The symbol at position i of s is denoted by s[i].\nA substring of s can be represented as s[j:k], where j and k represent the starting and ending positions of the substring in s; for example, if s = \"AUGCUUCAGAAAGGUCUUACG\", then s[2:5] = \"UGCU\".\nThe location of a substring s[j:k] is its beginning position j; note that t will have multiple locations in s if it occurs more than once as a substring of s (see the Sample below).\nGiven: Two DNA strings s and t (each of length at most 1 kbp).\nReturn: All locations of t as a substring of s.\nDifferent programming languages use different notations for positions of symbols in strings. Above, we use 1-based numbering, as opposed to 0-based numbering, which is used in Python.  For s = \"AUGCUUCAGAAAGGUCUUACG\", 1-based numbering would state that s[1] = 'A' is the first symbol of the string, whereas this symbol is represented by s[0] in 0-based numbering.  The idea of 0-based numbering propagates to substring indexing, so that s[2:5] becomes \"GCUU\" instead of \"UGCU\".\nNote that in some programming languages, such as Python, s[j:k] returns only fragment from index j up to but not including index k, so that s[2:5] actually becomes \"UGC\", not \"UGCU\".\n",
    "data": "GATATATGCATATACTT\nATAT",
    "output": "2 4 10",
    "topics": "String Algorithms"
  },
  "('10', 'CONS')": {
    "className": "Problem",
    "moduleName": "model.Problem",
    "num": 10,
    "id": "CONS",
    "title": "Consensus and Profile",
    "body": "A matrix is a rectangular table of values divided into rows and columns.  An m \\times n matrix has m rows and n columns.  Given a matrix A, we write A_{i, j} to indicate the value found at the intersection of row i and column j.\nSay that we have a collection of DNA strings, all having the same length n.  Their profile matrix is a 4 \\times n matrix P in which P_{1,j} represents the number of times that 'A' occurs in the jth position of one of the strings, P_{2,j} represents the number of times that C occurs in the jth position, and so on (see below).\nA consensus string c is a string of length n formed from our collection by taking the most common symbol at each position; the jth symbol of c therefore corresponds to the symbol having the maximum value in the j-th column of the profile matrix. Of course, there may be more than one most common symbol, leading to multiple possible consensus strings.\n  A T C C A G C T G G G C A A C T A T G G A T C T DNA StringsA A G C A A C C T T G G A A C T A T G C C A T T A T G G C A C T  A \u00a0 5 1 0 0 5 5 0 0 ProfileC \u00a0 0 0 1 4 2 0 6 1 G \u00a0 1 1 6 3 0 1 0 0 T \u00a0 1 5 0 0 0 1 1 6  ConsensusA T G C A A C T  \nGiven: A collection of at most 10 DNA strings of equal length (at most 1 kbp) in FASTA format.\nReturn: A consensus string and profile matrix for the collection. (If several possible consensus strings exist, then you may return any one of them.)\n",
    "data": ">Rosalind_1\nATCCAGCT\n>Rosalind_2\nGGGCAACT\n>Rosalind_3\nATGGATCT\n>Rosalind_4\nAAGCAACC\n>Rosalind_5\nTTGGAACT\n>Rosalind_6\nATGCCATT\n>Rosalind_7\nATGGCACT",
    "output": "ATGCAACT\nA: 5 1 0 0 5 5 0 0\nC: 0 0 1 4 2 0 6 1\nG: 1 1 6 3 0 1 0 0\nT: 1 5 0 0 0 1 1 6",
    "topics": "String Algorithms"
  },
  "('11', 'FIBD')": {
    "className": "Problem",
    "moduleName": "model.Problem",
    "num": 11,
    "id": "FIBD",
    "title": "Mortal Fibonacci Rabbits",
    "body": "Recall the definition of the Fibonacci numbers from \u201cRabbits and Recurrence Relations\u201d, which followed the recurrence relation F_n = F_{n-1} + F_{n-2} and assumed that each pair of rabbits reaches maturity in one month and produces a single pair of offspring (one male, one female) each subsequent month.\nOur aim is to somehow modify this recurrence relation to achieve a dynamic programming solution in the case that all rabbits die out after a fixed number of months.  See Figure 4 for a depiction of a rabbit tree in which rabbits live for three months (meaning that they reproduce only twice before dying).\nGiven: Positive integers n \\leq 100 and m \\leq 20.\nReturn: The total number of pairs of rabbits that will remain after the n-th month if all rabbits live for m months.\n",
    "data": "6 3",
    "output": "4",
    "topics": "Combinatorics, Dynamic Programming"
  },
  "('12', 'GRPH')": {
    "className": "Problem",
    "moduleName": "model.Problem",
    "num": 12,
    "id": "GRPH",
    "title": "Overlap Graphs",
    "body": "A graph whose nodes have all been labeled can be represented by an adjacency list, in which each row of the list contains the two node labels corresponding to a unique edge.\nA directed graph (or digraph) is a graph containing directed edges, each of which has an orientation. That is, a directed edge is represented by an arrow instead of a line segment; the starting and ending nodes of an edge form its tail and head, respectively.  The directed edge with tail v and head w is represented by (v, w) (but not by (w, v)).  A directed loop is a directed edge of the form (v, v).\nFor a collection of strings and a positive integer k, the overlap graph for the strings is a directed graph \\mathrm{O}_k in which each string is represented by a node, and string s is connected to string t with a directed edge when there is a length k suffix of s that matches a length k prefix of t, as long as s \\neq t; we demand s \\neq t to prevent directed loops in the overlap graph (although directed cycles may be present).\nGiven: A collection of DNA strings in FASTA format having total length at most 10 kbp.\nReturn: The adjacency list corresponding to \\mathrm{O}_3.  You may return edges in any order.\nIf you are looking for a way to actually visualize graphs as you are working through the Rosalind site, then you may like to consider Graphviz (link here), a cross-platform application for rendering graphs.\n",
    "data": ">Rosalind_0498\nAAATAAA\n>Rosalind_2391\nAAATTTT\n>Rosalind_2323\nTTTTCCC\n>Rosalind_0442\nAAATCCC\n>Rosalind_5013\nGGGTGGG",
    "output": "Rosalind_0498 Rosalind_2391\nRosalind_0498 Rosalind_0442\nRosalind_2391 Rosalind_2323",
    "topics": "Graph Algorithms"
  },
  "('13', 'IEV')": {
    "className": "Problem",
    "moduleName": "model.Problem",
    "num": 13,
    "id": "IEV",
    "title": "Calculating Expected Offspring",
    "body": "For a random variable X taking integer values between 1 and n, the expected value of X is \\mathrm{E}(X) = \\sum_{k=1}^{n}{k \\times \\mathrm{Pr}(X = k)}. The expected value offers us a way of taking the long-term average of a random variable over a large number of trials.\nAs a motivating example, let X be the number on a six-sided die.  Over a large number of rolls, we should expect to obtain an average of 3.5 on the die (even though it's not possible to roll a 3.5). The formula for expected value confirms that \\mathrm{E}(X) = \\sum_{k=1}^{6} k \\times \\mathrm{Pr}(X = k) = 3.5.\nMore generally, a random variable for which every one of a number of equally spaced outcomes has the same probability is called a uniform random variable (in the die example, this \"equal spacing\" is equal to 1). We can generalize our die example to find that if X is a uniform random variable with minimum possible value a and maximum possible value b, then \\mathrm{E}(X) = \\frac{a+b}{2}. You may also wish to verify that for the dice example, if Y is the random variable associated with the outcome of a second die roll, then \\mathrm{E}(X+Y) = 7.\nGiven: Six nonnegative integers, each of which does not exceed 20,000. The integers correspond to the number of couples in a population possessing each genotype pairing for a given factor. In order, the six given integers represent the number of couples having the following genotypes:\nReturn: The expected number of offspring displaying the dominant phenotype in the next generation, under the assumption that every couple has exactly two offspring.\n",
    "data": "1 0 0 1 0 1",
    "output": "3.5",
    "topics": "Heredity, Probability"
  },
  "('14', 'LCSM')": {
    "className": "Problem",
    "moduleName": "model.Problem",
    "num": 14,
    "id": "LCSM",
    "title": "Finding a Shared Motif",
    "body": "A common substring of a collection of strings is a substring of every member of the collection.  We say that a common substring is a longest common substring if there does not exist a longer common substring.  For example, \"CG\" is a common substring of \"ACGTACGT\" and \"AACCGTATA\", but it is not as long as possible; in this case, \"CGTA\" is a longest common substring of \"ACGTACGT\" and \"AACCGTATA\".\nNote that the longest common substring is not necessarily unique; for a simple example, \"AA\" and \"CC\" are both longest common substrings of \"AACC\" and \"CCAA\".\nGiven: A collection of k (k \\leq 100) DNA strings of length at most 1 kbp each in FASTA format.\nReturn: A longest common substring of the collection. (If multiple solutions exist, you may return any single solution.)\n",
    "data": ">Rosalind_1\nGATTACA\n>Rosalind_2\nTAGACCA\n>Rosalind_3\nATACA",
    "output": "AC",
    "topics": "String Algorithms"
  },
  "('15', 'LIA')": {
    "className": "Problem",
    "moduleName": "model.Problem",
    "num": 15,
    "id": "LIA",
    "title": "Independent Alleles",
    "body": "Two events A and B are independent if \\mathrm{Pr}(A \\textrm{ and } B) is equal to \\mathrm{Pr}(A) \\times \\mathrm{Pr}(B).  In other words, the events do not influence each other, so that we may simply calculate each of the individual probabilities separately and then multiply.\nMore generally, random variables X and Y are independent if whenever A and B are respective events for X and Y, A and B are independent (i.e., \\mathrm{Pr}(A \\textrm{ and } B) = \\mathrm{Pr}(A) \\times \\mathrm{Pr}(B)).\nAs an example of how helpful independence can be for calculating probabilities, let X and Y represent the numbers showing on two six-sided dice.  Intuitively, the number of pips showing on one die should not affect the number showing on the other die. If we want to find the probability that X + Y is odd, then we don't need to draw a tree diagram and consider all possibilities. We simply first note that for X+Y to be odd, either X is even and Y is odd or X is odd and Y is even. In terms of probability, \\mathrm{Pr}(X+Y \\textrm{ is odd}) = \\mathrm{Pr}(X \\textrm{ is even and } Y \\textrm{ is odd}) + \\mathrm{Pr}(X \\textrm{ is odd and } Y \\textrm{ is even}). Using independence, this becomes \\left[\\mathrm{Pr}(X \\textrm{ is even}) \\times \\mathrm{Pr}(Y \\textrm{ is odd})\\right] + \\left[\\mathrm{Pr}(X \\textrm{ is odd}) \\times \\mathrm{Pr}(Y \\textrm{ is even})\\right], or \\left(\\frac{1}{2}\\right)^2 + \\left(\\frac{1}{2}\\right)^2 = \\frac{1}{2}. You can verify this result in Figure 2, which shows all 36 outcomes for rolling two dice.\nGiven: Two positive integers k (k \\leq 7) and N (N \\leq 2^k).  In this problem, we begin with Tom, who in the 0th generation has genotype Aa Bb.  Tom has two children in the 1st generation, each of whom has two children, and so on. Each organism always mates with an organism having genotype Aa Bb.\nReturn: The probability that at least N Aa Bb organisms will belong to the k-th generation of Tom's family tree (don't count the Aa Bb mates at each level).  Assume that Mendel's second law holds for the factors.\nTwo random variables are dependent if they are not independent. For an example of dependent random variables, recall our example in \u201cMendel's First Law\u201d of drawing two balls from a bag containing 3 red balls and 2 blue balls. If X represents the color of the first ball drawn and Y is the color of the second ball drawn (without replacement), then let A be the event \"X is red\" and B be the event Y is blue.  In this case, the probability tree diagram illustrated in Figure 3 demonstrates that \\mathrm{Pr}(A \\textrm{ and } B) = \\frac{3}{10}.  Yet we can also see that \\mathrm{Pr}(A) = \\frac{3}{5} and \\mathrm{Pr}(B) = \\frac{3}{10} + \\frac{1}{10} = \\frac{2}{5}. We can now see that \\mathrm{Pr}(A \\textrm{ and } B) \\neq \\mathrm{Pr}(A) \\times \\mathrm{Pr}(B).\n",
    "data": "2 1",
    "output": "0.684",
    "topics": "Heredity, Probability"
  },
  "('16', 'MPRT')": {
    "className": "Problem",
    "moduleName": "model.Problem",
    "num": 16,
    "id": "MPRT",
    "title": "Finding a Protein Motif",
    "body": "To allow for the presence of its varying forms, a protein motif is represented by a shorthand as follows: [XY] means \"either X or Y\" and {X} means \"any amino acid except X.\"  For example, the N-glycosylation motif is written as N{P}[ST]{P}.\nYou can see the complete description and features of a particular protein by its access ID \"uniprot_id\" in the UniProt database, by inserting the ID number into\nAlternatively, you can obtain a protein sequence in FASTA format by following\nFor example, the data for protein B5ZC00 can be found at http://www.uniprot.org/uniprot/B5ZC00.\nGiven: At most 15 UniProt Protein Database access IDs.\nReturn: For each protein possessing the N-glycosylation motif, output its given access ID followed by a list of locations in the protein string where the motif can be found.\nSome entries in UniProt have one primary (citable) accession number and some secondary numbers, appearing due to merging or demerging entries. In this problem, you may be given any type of ID. If you type the secondary ID into the UniProt query, then you will be automatically redirected to the page containing the primary ID. You can find more information about UniProt IDs here.\n",
    "data": "A2Z669\nB5ZC00\nP07204_TRBM_HUMAN\nP20840_SAG1_YEAST",
    "output": "B5ZC00\n85 118 142 306 395\nP07204_TRBM_HUMAN\n47 115 116 382 409\nP20840_SAG1_YEAST\n79 109 135 248 306 348 364 402 485 501 614",
    "topics": "File Formats, Proteomics"
  },
  "('17', 'MRNA')": {
    "className": "Problem",
    "moduleName": "model.Problem",
    "num": 17,
    "id": "MRNA",
    "title": "Inferring mRNA from Protein",
    "body": "For positive integers a and n, a modulo n (written a\\mod n in shorthand) is the remainder when a is divided by n.  For example, 29 \\mod 11 = 7 because 29 = 11 \\times 2 + 7.\nModular arithmetic is the study of addition, subtraction, multiplication, and division with respect to the modulo operation.  We say that a and b are congruent modulo n if a \\mod n = b \\mod n; in this case, we use the notation a \\equiv b \\mod n.\nTwo useful facts in modular arithmetic are that if a \\equiv b \\mod n and c \\equiv d \\mod n, then a+c \\equiv b+d \\mod n and a \\times c \\equiv b \\times d \\mod n.  To check your understanding of these rules, you may wish to verify these relationships for a = 29, b = 73, c = 10, d = 32, and n = 11.\nAs you will see in this exercise, some Rosalind problems will ask for a (very large) integer solution modulo a smaller number to avoid the computational pitfalls that arise with storing such large numbers.\nGiven: A protein string of length at most 1000 aa.\nReturn: The total number of different RNA strings from which the protein could have been translated, modulo 1,000,000. (Don't neglect the importance of the stop codon in protein translation.)\nWhat does it mean intuitively to take a number modulo 1,000,000?\n",
    "data": "MA",
    "output": "12",
    "topics": "Combinatorics"
  },
  "('18', 'ORF')": {
    "className": "Problem",
    "moduleName": "model.Problem",
    "num": 18,
    "id": "ORF",
    "title": "Open Reading Frames",
    "body": "Either strand of a DNA double helix can serve as the coding strand for RNA transcription. Hence, a given DNA string implies six total reading frames, or ways in which the same region of DNA can be translated into amino acids: three reading frames result from reading the string itself, whereas three more result from reading its reverse complement.\nAn open reading frame (ORF) is one which starts from the start codon and ends by stop codon, without any other stop codons in between. Thus, a candidate protein string is derived by translating an open reading frame into amino acids until a stop codon is reached.\nGiven: A DNA string s of length at most 1 kbp in FASTA format.\nReturn: Every distinct candidate protein string that can be translated from ORFs of s. Strings can be returned in any order.\n",
    "data": ">Rosalind_99\nAGCCATGTAGCTAACTCAGGTTACATGGGGATGACCCCGCGACTTGGATTAGAGTCTCTTTTGGAATAAGCCTGAATGATCCGAGTAGCATCTCAG",
    "output": "MLLGSFRLIPKETLIQVAGSSPCNLS\nM\nMGMTPRLGLESLLE\nMTPRLGLESLLE",
    "topics": "Combinatorics"
  },
  "('19', 'PERM')": {
    "className": "Problem",
    "moduleName": "model.Problem",
    "num": 19,
    "id": "PERM",
    "title": "Enumerating Gene Orders",
    "body": "A permutation of length n is an ordering of the positive integers \\{1, 2, \\ldots, n\\}. For example, \\pi = (5, 3, 2, 1, 4) is a permutation of length 5.\nGiven: A positive integer n \\leq 7.\nReturn: The total number of permutations of length n, followed by a list of all such permutations (in any order).\n",
    "data": "3",
    "output": "6\n1 2 3\n1 3 2\n2 1 3\n2 3 1\n3 1 2\n3 2 1",
    "topics": "Combinatorics, Genome Rearrangements"
  },
  "('20', 'PRTM')": {
    "className": "Problem",
    "moduleName": "model.Problem",
    "num": 20,
    "id": "PRTM",
    "title": "Calculating Protein Mass",
    "body": "In a weighted alphabet, every symbol is assigned a positive real number called a weight. A string formed from a weighted alphabet is called a weighted string, and its weight is equal to the sum of the weights of its symbols.\nThe standard weight assigned to each member of the 20-symbol amino acid alphabet is the monoisotopic mass of the corresponding amino acid.\nGiven: A protein string P of length at most 1000 aa.\nReturn: The total weight of P.  Consult the monoisotopic mass table.\n",
    "data": "SKADYEK",
    "output": "821.392",
    "topics": "Computational Mass Spectrometry"
  },
  "('21', 'REVP')": {
    "className": "Problem",
    "moduleName": "model.Problem",
    "num": 21,
    "id": "REVP",
    "title": "Locating Restriction Sites",
    "body": "A DNA string is a reverse palindrome if it is equal to its reverse complement. For instance, GCATGC is a reverse palindrome because its reverse complement is GCATGC. See Figure 2.\nGiven: A DNA string of length at most 1 kbp in FASTA format.\nReturn: The position and length of every reverse palindrome in the string having length between 4 and 12.  You may return these pairs in any order.\nYou may be curious how the bacterium prevents its own DNA from being cut by restriction enzymes.  The short answer is that it locks itself from being cut through a chemical process called DNA methylation.\n",
    "data": ">Rosalind_24\nTCAATGCATGCGGGTCTATATGCAT",
    "output": "4 6\n5 4\n6 6\n7 4\n17 4\n18 4\n20 6\n21 4",
    "topics": "String Algorithms"
  },
  "('22', 'SPLC')": {
    "className": "Problem",
    "moduleName": "model.Problem",
    "num": 22,
    "id": "SPLC",
    "title": "RNA Splicing",
    "body": "After identifying the exons and introns of an RNA string, we only need to delete the introns and concatenate the exons to form a new string ready for translation.\nGiven: A DNA string s (of length at most 1 kbp) and a collection of substrings of s acting as introns.  All strings are given in FASTA format.\nReturn: A protein string resulting from transcribing and translating the exons of s. (Note: Only one solution will exist for the dataset provided.)\n",
    "data": ">Rosalind_10\nATGGTCTACATAGCTGACAAACAGCACGTAGCAATCGGTCGAATCTCGAGAGGCATATGGTCACATGATCGGTCGAGCGTGTTTCAAAGTTTGCGCCTAG\n>Rosalind_12\nATCGGTCGAA\n>Rosalind_15\nATCGGTCGAGCGTGT",
    "output": "MVYIADKQHVASREAYGHMFKVCA",
    "topics": "String Algorithms"
  },
  "('23', 'LEXF')": {
    "className": "Problem",
    "moduleName": "model.Problem",
    "num": 23,
    "id": "LEXF",
    "title": "Enumerating k-mers Lexicographically",
    "body": "Assume that an alphabet \\mathscr{A} has a predetermined order; that is, we write the alphabet as a permutation \\mathscr{A} = (a_1, a_2, \\ldots, a_k), where a_1 < a_2 < \\cdots < a_k. For instance, the English alphabet is organized as (\\textrm{A}, \\textrm{B}, \\ldots, \\textrm{Z}).\nGiven two strings s and t having the same length n, we say that s precedes t in the lexicographic order (and write s <_{\\textrm{Lex}} t) if the first symbol s[j] that doesn't match t[j] satisfies s_j < t_j in \\mathscr{A}.\nGiven: A collection of at most 10 symbols defining an ordered alphabet, and a positive integer n (n \\leq 10).\nReturn: All strings of length n that can be formed from the alphabet, ordered lexicographically (use the standard order of symbols in the English alphabet).\n",
    "data": "A C G T\n2",
    "output": "AA\nAC\nAG\nAT\nCA\nCC\nCG\nCT\nGA\nGC\nGG\nGT\nTA\nTC\nTG\nTT",
    "topics": "String Algorithms"
  },
  "('24', 'LGIS')": {
    "className": "Problem",
    "moduleName": "model.Problem",
    "num": 24,
    "id": "LGIS",
    "title": "Longest Increasing Subsequence",
    "body": "A subsequence of a permutation is a collection of elements of the permutation in the order that they appear.  For example, (5, 3, 4) is a subsequence of (5, 1, 3, 4, 2).\nA subsequence is increasing if the elements of the subsequence increase, and decreasing if the elements decrease. For example, given the permutation (8, 2, 1, 6, 5, 7, 4, 3, 9), an increasing subsequence is (2, 6, 7, 9), and a decreasing subsequence is (8, 6, 5, 4, 3).  You may verify that these two subsequences are as long as possible.\nGiven: A positive integer n \\leq 10000 followed by a permutation \\pi of length n.\nReturn: A longest increasing subsequence of \\pi, followed by a longest decreasing subsequence of \\pi.\nAdapted from Jones & Pevzner, *An Introduction to Bioinformatics Algorithms, Problem 6.48.\n",
    "data": "5\n5 1 4 2 3",
    "output": "1 2 3\n5 4 2",
    "topics": "Dynamic Programming, Genome Rearrangements"
  },
  "('25', 'LONG')": {
    "className": "Problem",
    "moduleName": "model.Problem",
    "num": 25,
    "id": "LONG",
    "title": "Genome Assembly as Shortest Superstring",
    "body": "For a collection of strings, a larger string containing every one of the smaller strings as a substring is called a superstring.\nBy the assumption of parsimony, a shortest possible superstring over a collection of reads serves as a candidate chromosome.\nGiven: At most 50 DNA strings of approximately equal length, not exceeding 1 kbp, in FASTA format (which represent reads deriving from the same strand of a single linear chromosome).\nThe dataset is guaranteed to satisfy the following condition: there exists a unique way to reconstruct the entire chromosome from these reads by gluing together pairs of reads that overlap by more than half their length.\nReturn: A shortest superstring containing all the given strings (thus corresponding to a reconstructed chromosome).\nAlthough the goal of fragment assembly is to produce an entire genome, in practice it is only possible to construct several contiguous portions of each chromosome, called contigs.  Furthermore, the assumption made above that reads all derive from the same strand is also practically unrealistic; in reality, researchers will not know the strand of DNA from which a given read has been sequenced.\n",
    "data": ">Rosalind_56\nATTAGACCTG\n>Rosalind_57\nCCTGCCGGAA\n>Rosalind_58\nAGACCTGCCG\n>Rosalind_59\nGCCGGAATAC",
    "output": "ATTAGACCTGCCGGAATAC",
    "topics": "Genome Assembly"
  },
  "('26', 'PMCH')": {
    "className": "Problem",
    "moduleName": "model.Problem",
    "num": 26,
    "id": "PMCH",
    "title": "Perfect Matchings and RNA Secondary Structures",
    "body": "A matching in a graph \\mathrm{G} is a collection of edges of \\mathrm{G} for which no node belongs to more than one edge in the collection. See Figure 2 for examples of matchings. If G contains an even number of nodes (say 2n), then a matching on G is perfect if it contains n edges, which is clearly the maximum possible.  An example of a graph containing a perfect matching is shown in Figure 3.\nFirst, let K_n denote the complete graph on 2n labeled nodes, in which every node is connected to every other node with an edge, and let p_n denote the total number of perfect matchings in K_n. For a given node x, there are 2n - 1 ways to join x to the other nodes in the graph, after which point we must form a perfect matching on the remaining 2n - 2 nodes.  This reasoning provides us with the recurrence relation p_n = (2n - 1)\\cdot p_{n-1}; using the fact that p_1 is 1, this recurrence relation implies the closed equation p_n = (2n - 1)(2n - 3)(2n - 5)\\cdots (3)(1).\nGiven an RNA string s = s_1 \\ldots s_n, a bonding graph for s is formed as follows. First, assign each symbol of s to a node, and arrange these nodes in order around a circle, connecting them with edges called adjacency edges. Second, form all possible edges {A, U} and {C, G}, called basepair edges; we will represent basepair edges with dashed edges, as illustrated by the bonding graph in Figure 4.\nNote that a matching contained in the basepair edges will represent one possibility for base pairing interactions in s, as shown in Figure 5. For such a matching to exist, s must have the same number of occurrences of 'A' as 'U' and the same number of occurrences of 'C' as 'G'.\nGiven: An RNA string s of length at most 80 bp having the same number of occurrences of 'A' as 'U' and the same number of occurrences of 'C' as 'G'.\nReturn: The total possible number of perfect matchings of basepair edges in the bonding graph of s.\n",
    "data": ">Rosalind_23\nAGCUAGUCAU",
    "output": "12",
    "topics": "Combinatorics, Dynamic Programming, String Algorithms"
  },
  "('27', 'PPER')": {
    "className": "Problem",
    "moduleName": "model.Problem",
    "num": 27,
    "id": "PPER",
    "title": "Partial Permutations",
    "body": "A partial permutation is an ordering of only k objects taken from a collection containing n objects (i.e., k \\leq n). For example, one partial permutation of three of the first eight positive integers is given by (5, 7, 2).\nThe statistic P(n, k) counts the total number of partial permutations of k objects that can be formed from a collection of n objects.  Note that P(n, n) is just the number of permutations of n objects, which we found to be equal to n! = n (n-1) (n-2) \\cdots (3) (2) in \u201cEnumerating Gene Orders\u201d.\nGiven: Positive integers n and k such that 100 \\geq n > 0 and 10 \\geq k > 0.\nReturn: The total number of partial permutations P(n, k), modulo 1,000,000.\n",
    "data": "21 7",
    "output": "51200",
    "topics": "Combinatorics, Genome Rearrangements"
  },
  "('28', 'PROB')": {
    "className": "Problem",
    "moduleName": "model.Problem",
    "num": 28,
    "id": "PROB",
    "title": "Introduction to Random Strings",
    "body": "An array is a structure containing an ordered collection of objects (numbers, strings, other arrays, etc.). We let A[k] denote the k-th value in array A.  You may like to think of an array as simply a matrix having only one row.\nA random string is constructed so that the probability of choosing each subsequent symbol is based on a fixed underlying symbol frequency.\nGC-content offers us natural symbol frequencies for constructing random DNA strings. If the GC-content is x, then we set the symbol frequencies of C and G equal to \\frac{x}{2} and the symbol frequencies of A and T equal to \\frac{1-x}{2}.  For example, if the GC-content is 40%, then as we construct the string, the next symbol is 'G'/'C' with probability 0.2, and the next symbol is 'A'/'T' with probability 0.3.\nIn practice, many probabilities wind up being very small. In order to work with small probabilities, we may plug them into a function that \"blows them up\" for the sake of comparison. Specifically, the common logarithm of x (defined for x > 0 and denoted \\log_{10}(x)) is the exponent to which we must raise 10 to obtain x.\nSee Figure 1 for a graph of the common logarithm function y = \\log_{10}(x). In this graph, we can see that the logarithm of x-values between 0 and 1 always winds up mapping to y-values between -\\infty and 0: x-values near 0 have logarithms close to -\\infty, and x-values close to 1 have logarithms close to 0. Thus, we will select the common logarithm as our function to \"blow up\" small probability values for comparison.\nGiven: A DNA string s of length at most 100 bp and an array A containing at most 20 numbers between 0 and 1.\nReturn: An array B having the same length as A in which B[k] represents the common logarithm of the probability that a random string constructed with the GC-content found in A[k] will match s exactly.\nOne property of the logarithm function is that for any positive numbers x and y, \\log_{10}(x \\cdot y) = \\log_{10}(x) + \\log_{10}(y).\n",
    "data": "ACGATACAA\n0.129 0.287 0.423 0.476 0.641 0.742 0.783",
    "output": "-5.737 -5.217 -5.263 -5.360 -5.958 -6.628 -7.009",
    "topics": "Probability"
  },
  "('29', 'SIGN')": {
    "className": "Problem",
    "moduleName": "model.Problem",
    "num": 29,
    "id": "SIGN",
    "title": "Enumerating Oriented Gene Orderings",
    "body": "A signed permutation of length n is some ordering of the positive integers \\{1, 2, \\ldots, n\\} in which each integer is then provided with either a positive or negative sign (for the sake of simplicity, we omit the positive sign). For example, \\pi = (5, -3, -2, 1, 4) is a signed permutation of length 5.\nGiven: A positive integer n \\leq 6.\nReturn: The total number of signed permutations of length n, followed by a list of all such permutations (you may list the signed permutations in any order).\n",
    "data": "2",
    "output": "8\n-1 -2\n-1 2\n1 -2\n1 2\n-2 -1\n-2 1\n2 -1\n2 1",
    "topics": "Combinatorics, Genome Rearrangements"
  },
  "('30', 'SSEQ')": {
    "className": "Problem",
    "moduleName": "model.Problem",
    "num": 30,
    "id": "SSEQ",
    "title": "Finding a Spliced Motif",
    "body": "A subsequence of a string is a collection of symbols contained in order (though not necessarily contiguously) in the string (e.g., ACG is a subsequence of TATGCTAAGATC). The indices of a subsequence are the positions in the string at which the symbols of the subsequence appear; thus, the indices of ACG in TATGCTAAGATC can be represented by (2, 5, 9).\nAs a substring can have multiple locations, a subsequence can have multiple collections of indices, and the same index can be reused in more than one appearance of the subsequence; for example, ACG is a subsequence of AACCGGTT in  8 different ways.\nGiven: Two DNA strings s and t (each of length at most 1 kbp) in FASTA format.\nReturn: One collection of indices of s in which the symbols of t appear as a subsequence of s. If multiple solutions exist, you may return any one.\nFor the mathematically inclined, we may equivalently say that t = t_1 t_2 \\cdots t_m is a subsequence of s = s_1 s_2 \\cdots s_n if the characters of t appear in the same order within s.  Even more formally, a subsequence of s is a string s_{i_1} s_{i_2} \\ldots s_{i_k}, where 1 \\leq i_1 < i_2 \\cdots < i_k \\leq n.\n",
    "data": ">Rosalind_14\nACGTACGTGACG\n>Rosalind_18\nGTA",
    "output": "3 8 10",
    "topics": "String Algorithms"
  },
  "('31', 'TRAN')": {
    "className": "Problem",
    "moduleName": "model.Problem",
    "num": 31,
    "id": "TRAN",
    "title": "Transitions and Transversions",
    "body": "For DNA strings s_1 and s_2 having the same length, their transition/transversion ratio R(s_1, s_2) is the ratio of the total number of transitions to the total number of transversions, where symbol substitutions are inferred from mismatched corresponding symbols as when calculating Hamming distance (see \u201cCounting Point Mutations\u201d).\nGiven: Two DNA strings s_1 and s_2 of equal length (at most 1 kbp).\nReturn: The transition/transversion ratio R(s_1, s_2).\n",
    "data": ">Rosalind_0209\nGCAACGCACAACGAAAACCCTTAGGGACTGGATTATTTCGTGATCGTTGTAGTTATTGGA\nAGTACGGGCATCAACCCAGTT\n>Rosalind_2200\nTTATCTGACAAAGAAAGCCGTCAACGGCTGGATAATTTCGCGATCGTGCTGGTTACTGGC\nGGTACGAGTGTTCCTTTGGGT",
    "output": "1.21428571429",
    "topics": "Alignment"
  },
  "('32', 'TREE')": {
    "className": "Problem",
    "moduleName": "model.Problem",
    "num": 32,
    "id": "TREE",
    "title": "Completing a Tree",
    "body": "An undirected graph is connected if there is a path connecting any two nodes. A tree is a connected (undirected) graph containing no cycles; this definition forces the tree to have a branching structure organized around a central core of nodes, just like its living counterpart. See Figure 2.\nWe have already grown familiar with trees in \u201cMendel's First Law\u201d, where we introduced the probability tree diagram to visualize the outcomes of a random variable.\nIn the creation of a phylogeny, taxa are encoded by the tree's leaves, or nodes having degree 1. A node of a tree having degree larger than 1 is called an internal node.\nGiven: A positive integer n (n \\leq 1000) and an adjacency list corresponding to a graph on n nodes that contains no cycles.\nReturn: The minimum number of edges that can be added to the graph to produce a tree.\nAfter solving this problem, a standard mathematical exercise for the technically minded  is to verify that every tree having 2 or more nodes must contain at least two leaves.\n",
    "data": "10\n1 2\n2 8\n4 10\n5 9\n6 10\n7 9",
    "output": "3",
    "topics": "Graph Algorithms, Phylogeny"
  },
  "('33', 'CAT')": {
    "className": "Problem",
    "moduleName": "model.Problem",
    "num": 33,
    "id": "CAT",
    "title": "Catalan Numbers and RNA Secondary Structures",
    "body": "A matching in a graph is noncrossing if none of its edges cross each other.  If we assume that the n nodes of this graph are arranged around a circle, and if we label these nodes with positive integers between 1 and n, then a matching is noncrossing as long as there are not edges \\{i, j\\} and \\{k, l\\} such that i < k < j < l.\nA noncrossing matching of basepair edges in the bonding graph corresponding to an RNA string will correspond to a possible secondary structure of the underlying RNA strand that lacks pseudoknots, as shown in Figure 3.\nIn this problem, we will consider counting noncrossing perfect matchings of basepair edges. As a motivating example of how to count noncrossing perfect matchings, let c_n denote the number of noncrossing perfect matchings in the complete graph K_{2n}. After setting c_0 = 1, we can see that c_1 should equal 1 as well. As for the case of a general n, say that the nodes of K_{2n} are labeled with the positive integers from 1 to 2n.  We can join node 1 to any of the remaining 2n - 1 nodes; yet once we have chosen this node (say m), we cannot add another edge to the matching that crosses the edge \\{1, m\\}. As a result, we must match all the edges on one side of \\{1, m\\} to each other. This requirement forces m to be even, so that we can write m = 2k for some positive integer k.\nThere are 2k - 2 nodes on one side of \\{1, m\\} and 2n - 2k nodes on the other side of \\{1, m\\}, so that in turn there will be c_{k-1} \\cdot c_{n - k} different ways of forming a perfect matching on the remaining nodes of K_{2n}. If we let m vary over all possible n - 1 choices of even numbers between 1 and 2n, then we obtain the recurrence relation c_n = \\sum_{k = 1}^{n}{c_{k-1} \\cdot c_{n-k}}. The resulting numbers c_n counting noncrossing perfect matchings in K_{2n} are called the Catalan numbers, and they appear in a huge number of other settings.  See Figure 4 for an illustration counting the first four Catalan numbers.\nGiven: An RNA string s having the same number of occurrences of 'A' as 'U' and the same number of occurrences of 'C' as 'G'. The length of the string is at most 300 bp.\nReturn: The total number of noncrossing perfect matchings of basepair edges in the bonding graph of s, modulo 1,000,000.\nWrite a function that counts Catalan numbers via dynamic programming.  How can we modify this function to apply to our given problem?\n",
    "data": ">Rosalind_57\nAUAU",
    "output": "2",
    "topics": "Combinatorics, Dynamic Programming, String Algorithms"
  },
  "('34', 'CORR')": {
    "className": "Problem",
    "moduleName": "model.Problem",
    "num": 34,
    "id": "CORR",
    "title": "Error Correction in Reads",
    "body": "As is the case with point mutations, the most common type of sequencing error occurs when a single nucleotide from a read is interpreted incorrectly.\nGiven: A collection of up to 1000 reads of equal length (at most 50 bp) in FASTA format. Some of these reads were generated with a single-nucleotide error. For each read s in the dataset, one of the following applies:\nReturn: A list of all corrections in the form \"[old read]->[new read]\".  (Each correction must be a single symbol substitution, and you may return the corrections in any order.)\n",
    "data": ">Rosalind_52\nTCATC\n>Rosalind_44\nTTCAT\n>Rosalind_68\nTCATC\n>Rosalind_28\nTGAAA\n>Rosalind_95\nGAGGA\n>Rosalind_66\nTTTCA\n>Rosalind_33\nATCAA\n>Rosalind_21\nTTGAT\n>Rosalind_18\nTTTCC",
    "output": "TTCAT->TTGAT\nGAGGA->GATGA\nTTTCC->TTTCA",
    "topics": "Genome Assembly"
  },
  "('35', 'INOD')": {
    "className": "Problem",
    "moduleName": "model.Problem",
    "num": 35,
    "id": "INOD",
    "title": "Counting Phylogenetic Ancestors",
    "body": "A binary tree is a tree in which each node has degree equal to at most 3.  The binary tree will be our main tool in the construction of phylogenies.\nA rooted tree is a tree in which one node (the root) is set aside to serve as the pinnacle of the tree. A standard graph theory exercise is to verify that for any two nodes of a tree, exactly one path connects the nodes. In a rooted tree, every node v will therefore have a single parent, or the unique node w such that the path from v to the root contains \\{v, w\\}.  Any other node x adjacent to v is called a child of v because v must be the parent of x; note that a node may have multiple children. In other words, a rooted tree possesses an ordered hierarchy from the root down to its leaves, and as a result, we may often view a rooted tree with undirected edges as a directed graph in which each edge is oriented from parent to child.  We should already be familiar with this idea; it's how the Rosalind problem tree works!\nEven though a binary tree can include nodes having degree 2, an unrooted binary tree is defined more specifically: all internal nodes have degree 3. In turn, a rooted binary tree is such that only the root has degree 2 (all other internal nodes have degree 3).\nGiven: A positive integer n (3 \\leq n \\leq 10000).\nReturn: The number of internal nodes of any unrooted binary tree having n leaves.\nIn solving \u201cCompleting a Tree\u201d, you may have formed the conjecture that a graph with no cycles and n nodes is a tree precisely when it has n-1 edges.  This is indeed a theorem of graph theory.\n",
    "data": "4",
    "output": "2",
    "topics": "Combinatorics, Phylogeny"
  },
  "('36', 'KMER')": {
    "className": "Problem",
    "moduleName": "model.Problem",
    "num": 36,
    "id": "KMER",
    "title": "k-Mer Composition",
    "body": "For a fixed positive integer k, order all possible k-mers taken from an underlying alphabet lexicographically.\nThen the k-mer composition of a string s can be represented by an array A for which A[m] denotes the number of times that the mth k-mer (with respect to the lexicographic order) appears in s.\nGiven: A DNA string s in FASTA format (having length at most 100 kbp).\nReturn: The 4-mer composition of s.\n",
    "data": ">Rosalind_6431\nCTTCGAAAGTTTGGGCCGAGTCTTACAGTCGGTCTTGAAGCAAAGTAACGAACTCCACGG\nCCCTGACTACCGAACCAGTTGTGAGTACTCAACTGGGTGAGAGTGCAGTCCCTATTGAGT\nTTCCGAGACTCACCGGGATTTTCGATCCAGCCTCAGTCCAGTCTTGTGGCCAACTCACCA\nAATGACGTTGGAATATCCCTGTCTAGCTCACGCAGTACTTAGTAAGAGGTCGCTGCAGCG\nGGGCAAGGAGATCGGAAAATGTGCTCTATATGCGACTAAAGCTCCTAACTTACACGTAGA\nCTTGCCCGTGTTAAAAACTCGGCTCACATGCTGTCTGCGGCTGGCTGTATACAGTATCTA\nCCTAATACCCTTCAGTTCGCCGCACAAAAGCTGGGAGTTACCGCGGAAATCACAG",
    "output": "4 1 4 3 0 1 1 5 1 3 1 2 2 1 2 0 1 1 3 1 2 1 3 1 1 1 1 2 2 5 1 3 0 2 2 1 1 1 1 3 1 0 0 1 5 5 1 5 0 2 0 2 1 2 1 1 1 2 0 1 0 0 1 1 3 2 1 0 3 2 3 0 0 2 0 8 0 0 1 0 2 1 3 0 0 0 1 4 3 2 1 1 3 1 2 1 3 1 2 1 2 1 1 1 2 3 2 1 1 0 1 1 3 2 1 2 6 2 1 1 1 2 3 3 3 2 3 0 3 2 1 1 0 0 1 4 3 0 1 5 0 2 0 1 2 1 3 0 1 2 2 1 1 0 3 0 0 4 5 0 3 0 2 1 1 3 0 3 2 2 1 1 0 2 1 0 2 2 1 2 0 2 2 5 2 2 1 1 2 1 2 2 2 2 1 1 3 4 0 2 1 1 0 1 2 2 1 1 1 5 2 0 3 2 1 1 2 2 3 0 3 0 1 3 1 2 3 0 2 1 2 2 1 2 3 0 1 2 3 1 1 3 1 0 1 1 3 0 2 1 2 2 0 2 1 1",
    "topics": "String Algorithms"
  },
  "('37', 'KMP')": {
    "className": "Problem",
    "moduleName": "model.Problem",
    "num": 37,
    "id": "KMP",
    "title": "Speeding Up Motif Finding",
    "body": "A prefix of a length n string s is a substring s[1:j]; a suffix of s is a substring s[k:n].\nThe failure array of s is an array P of length n for which P[k] is the length of the longest substring s[j:k] that is equal to some prefix s[1:k-j+1], where j cannot equal 1 (otherwise, P[k] would always equal k). By convention, P[1] = 0.\nGiven: A DNA string s (of length at most 100 kbp) in FASTA format.\nReturn: The failure array of s.\nIf you would like a more precise technical explanation of the Knuth-Morris-Pratt algorithm, please take a look at this site\n",
    "data": ">Rosalind_87\nCAGCATGGTATCACAGCAGAG",
    "output": "0 0 0 1 2 0 0 0 0 0 0 1 2 1 2 3 4 5 3 0 0",
    "topics": "String Algorithms"
  },
  "('38', 'LCSQ')": {
    "className": "Problem",
    "moduleName": "model.Problem",
    "num": 38,
    "id": "LCSQ",
    "title": "Finding a Shared Spliced Motif",
    "body": "A string u is a common subsequence of strings s and t if the symbols of u appear in order as a subsequence of both s and t. For example, \"ACTG\" is a common subsequence of \"AACCTTGG\" and \"ACACTGTGA\".\nAnalogously to the definition of longest common substring, u is a longest common subsequence of s and t if there does not exist a longer common subsequence of the two strings.  Continuing our above example, \"ACCTTG\" is a longest common subsequence of \"AACCTTGG\" and \"ACACTGTGA\", as is \"AACTGG\".\nGiven: Two DNA strings s and t (each having length at most 1 kbp) in FASTA format.\nReturn: A longest common subsequence of s and t. (If more than one solution exists, you may return any one.)\n",
    "data": ">Rosalind_23\nAACCTTGG\n>Rosalind_64\nACACTGTGA",
    "output": "AACTGG",
    "topics": "Dynamic Programming, String Algorithms"
  },
  "('39', 'LEXV')": {
    "className": "Problem",
    "moduleName": "model.Problem",
    "num": 39,
    "id": "LEXV",
    "title": "Ordering Strings of Varying Length Lexicographically",
    "body": "Say that we have strings s = s_1 s_2 \\cdots s_m and t = t_1 t_2 \\cdots t_n with m < n. Consider the substring t' = t[1:m]. We have two cases:\nGiven: A permutation of at most 12 symbols defining an ordered alphabet \\mathscr{A} and a positive integer n (n \\leq 4).\nReturn: All strings of length at most n formed from \\mathscr{A}, ordered lexicographically. (Note: As in \u201cEnumerating k-mers Lexicographically\u201d, alphabet order is based on the order in which the symbols are given.)\nWe can combine conditions (1) and (2) above into a single condition by adding a blank character \\emptyset to the beginning of our ordered alphabet.  Then, if s is shorter than t, we simply add as many instances of \\emptyset as necessary to make s and t the same length.\n",
    "data": "D N A\n3",
    "output": "D\nDD\nDDD\nDDN\nDDA\nDN\nDND\nDNN\nDNA\nDA\nDAD\nDAN\nDAA\nN\nND\nNDD\nNDN\nNDA\nNN\nNND\nNNN\nNNA\nNA\nNAD\nNAN\nNAA\nA\nAD\nADD\nADN\nADA\nAN\nAND\nANN\nANA\nAA\nAAD\nAAN\nAAA",
    "topics": "String Algorithms"
  },
  "('40', 'MMCH')": {
    "className": "Problem",
    "moduleName": "model.Problem",
    "num": 40,
    "id": "MMCH",
    "title": "Maximum Matchings and RNA Secondary Structures",
    "body": "The graph theoretical analogue of the quandary stated in the introduction above is that if we have an RNA string s that does not have the same number of occurrences of 'C' as 'G' and the same number of occurrences of 'A' as 'U', then the bonding graph of s cannot possibly possess a perfect matching among its basepair edges.  For example, see Figure 1; in fact, most bonding graphs will not contain a perfect matching.\nIn light of this fact, we define a maximum matching in a graph as a matching containing as many edges as possible.  See Figure 2 for three maximum matchings in graphs.\nA maximum matching of basepair edges will correspond to a way of forming as many base pairs as possible in an RNA string, as shown in Figure 3.\nGiven: An RNA string s of length at most 100.\nReturn: The total possible number of maximum matchings of basepair edges in the bonding graph of s.\n",
    "data": ">Rosalind_92\nAUGCUUC",
    "output": "6",
    "topics": "Combinatorics, Dynamic Programming, String Algorithms"
  },
  "('41', 'PDST')": {
    "className": "Problem",
    "moduleName": "model.Problem",
    "num": 41,
    "id": "PDST",
    "title": "Creating a Distance Matrix",
    "body": "For two strings s_1 and s_2 of equal length, the p-distance between them, denoted d_p(s_1, s_2), is the proportion of corresponding symbols that differ between s_1 and s_2.\nFor a general distance function d on n taxa s_1, s_2, \\ldots, s_n (taxa are often represented by genetic strings), we may encode the distances between pairs of taxa via a distance matrix D in which D_{i,j} = d(s_i, s_j).\nGiven: A collection of n (n \\leq 10) DNA strings s_1, \\ldots, s_n of equal length (at most 1 kbp). Strings are given in FASTA format.\nReturn: The matrix D corresponding to the p-distance d_p on the given strings.  As always, note that your answer is allowed an absolute error of 0.001.\n",
    "data": ">Rosalind_9499\nTTTCCATTTA\n>Rosalind_0942\nGATTCATTTC\n>Rosalind_6568\nTTTCCATTTT\n>Rosalind_1833\nGTTCCATTTA",
    "output": "0.00000 0.40000 0.10000 0.10000\n0.40000 0.00000 0.40000 0.30000\n0.10000 0.40000 0.00000 0.20000\n0.10000 0.30000 0.20000 0.00000",
    "topics": "Alignment, Phylogeny"
  },
  "('42', 'REAR')": {
    "className": "Problem",
    "moduleName": "model.Problem",
    "num": 42,
    "id": "REAR",
    "title": "Reversal Distance",
    "body": "A reversal of a permutation creates a new permutation by inverting some interval of the permutation; (5, 2, 3, 1, 4), (5, 3, 4, 1, 2), and (4, 1, 2, 3, 5) are all reversals of (5, 3, 2, 1, 4). The reversal distance between two permutations \\pi and \\sigma, written d_{\\textrm{rev}}(\\pi, \\sigma), is the minimum number of reversals required to transform \\pi into \\sigma (this assumes that \\pi and \\sigma have the same length).\nGiven: A collection of at most 5 pairs of permutations, all of which have length 10.\nReturn: The reversal distance between each permutation pair.\nDon't be afraid to try an ugly solution.\n",
    "data": "1 2 3 4 5 6 7 8 9 10\n3 1 5 2 7 4 9 6 10 8\n\n3 10 8 2 5 4 7 1 6 9\n5 2 3 1 7 4 10 8 6 9\n\n8 6 7 9 4 1 3 10 2 5\n8 2 7 6 9 1 5 3 10 4\n\n3 9 10 4 1 8 6 7 5 2\n2 9 8 5 1 7 3 4 6 10\n\n1 2 3 4 5 6 7 8 9 10\n1 2 3 4 5 6 7 8 9 10",
    "output": "9 4 5 7 0",
    "topics": "Combinatorics, Genome Rearrangements"
  },
  "('43', 'RSTR')": {
    "className": "Problem",
    "moduleName": "model.Problem",
    "num": 43,
    "id": "RSTR",
    "title": "Matching Random Motifs",
    "body": "Our aim in this problem is to determine the probability with which a given motif (a known promoter, say) occurs in a randomly constructed genome. Unfortunately, finding this probability is tricky; instead of forming a long genome, we will form a large collection of smaller random strings having the same length as the motif; these smaller strings represent the genome's substrings, which we can then test against our motif.\nGiven a probabilistic event A, the complement of A is the collection A^{\\textrm{c}} of outcomes not belonging to A. Because A^{\\textrm{c}} takes place precisely when A does not, we may also call A^{\\textrm{c}} \"not A.\"\nFor a simple example, if A is the event that a rolled die is 2 or 4, then \\mathrm{Pr}(A) = \\frac{1}{3}.  A^{\\textrm{c}} is the event that the die is 1, 3, 5, or 6, and \\mathrm{Pr}(A^{\\textrm{c}}) = \\frac{2}{3}. In general, for any event we will have the identity that \\mathrm{Pr(A)} + \\mathrm{Pr}(A^{\\textrm{c}}) = 1.\nGiven: A positive integer N \\leq 100000, a number x between 0 and 1, and a DNA string s of length at most 10 bp.\nReturn: The probability that if N random DNA strings having the same length as s are constructed with GC-content x (see \u201cIntroduction to Random Strings\u201d), then at least one of the strings equals s. We allow for the same random string to be created more than once.\n",
    "data": "90000 0.6\nATAGCCGA",
    "output": "0.689",
    "topics": "Probability"
  },
  "('44', 'SSET')": {
    "className": "Problem",
    "moduleName": "model.Problem",
    "num": 44,
    "id": "SSET",
    "title": "Counting Subsets",
    "body": "A set is the mathematical term for a loose collection of objects, called elements. Examples of sets include \\{\\textrm{the moon, the sun, Wilford Brimley}\\} and \\mathbb{R}, the set containing all real numbers. We even have the empty set, represented by \\emptyset or \\{\\}, which contains no elements at all. Two sets are equal when they contain the same elements.  In other words, in contrast to permutations, the ordering of the elements of a set is unimportant (e.g., \\{\\textrm{the moon, the sun, Wilford Brimley}\\} is equivalent to \\{\\textrm{Wilford Brimley, the moon, the sun}\\}).  Sets are not allowed to contain duplicate elements, so that \\{\\textrm{Wilford Brimley, the sun, the sun}\\} is not a set.  We have already used sets of 2 elements to represent edges from a graph.\nA set A is a subset of B if every element of A is also an element of B, and we write A \\subseteq B.  For example, \\{\\textrm{the sun, the moon}\\} \\subseteq \\{\\textrm{the sun, the moon, Wilford Brimley}\\}, and \\emptyset is a subset of every set (including itself!).\nAs illustrated in the biological introduction, we can use subsets to represent the collection of taxa possessing a character.  However, the number of applications is endless; for example, an event in probability can now be defined as a subset of the set containing all possible outcomes.\nOur first question is to count the total number of possible subsets of a given set.\nGiven: A positive integer n (n \\leq 1000).\nReturn: The total number of subsets of \\{1, 2, \\ldots, n\\} modulo 1,000,000.\nWhat does counting subsets have to do with characters and \"ON\"/\"OFF\" switches?\n",
    "data": "3",
    "output": "8",
    "topics": "Combinatorics, Set Theory"
  },
  "('45', 'ASPC')": {
    "className": "Problem",
    "moduleName": "model.Problem",
    "num": 45,
    "id": "ASPC",
    "title": "Introduction to Alternative Splicing",
    "body": "In \u201cCounting Subsets\u201d, we saw that the total number of subsets of a set S containing n elements is equal to 2^n.\nHowever, if we intend to count the total number of subsets of S having a fixed size k, then we use the combination statistic C(n, k), also written \\binom{n}{k}.\nGiven: Positive integers n and m with 0 \\leq m \\leq n \\leq 2000.\nReturn: The sum of combinations C(n, k) for all k satisfying m \\leq k \\leq n, modulo 1,000,000.  In shorthand, \\sum_{k=m}^{n}{\\binom{n}{k}}.\n",
    "data": "6 3",
    "output": "42",
    "topics": "Combinatorics"
  },
  "('46', 'EDIT')": {
    "className": "Problem",
    "moduleName": "model.Problem",
    "num": 46,
    "id": "EDIT",
    "title": "Edit Distance",
    "body": "Given two strings s and t (of possibly different lengths), the edit distance d_{\\textrm{E}}(s, t) is the minimum number of edit operations needed to transform s into t, where an edit operation is defined as the substitution, insertion, or deletion of a single symbol.\nThe latter two operations incorporate the case in which a contiguous interval is inserted into or deleted from a string; such an interval is called a gap. For the purposes of this problem, the insertion or deletion of a gap of length k still counts as k distinct edit operations.\nGiven: Two protein strings s and t in FASTA format (each of length at most 1000 aa).\nReturn: The edit distance d_{\\textrm{E}}(s, t).\n",
    "data": ">Rosalind_39\nPLEASANTLY\n>Rosalind_11\nMEANLY",
    "output": "5",
    "topics": "Alignment, Dynamic Programming"
  },
  "('47', 'EVAL')": {
    "className": "Problem",
    "moduleName": "model.Problem",
    "num": 47,
    "id": "EVAL",
    "title": "Expected Number of Restriction Sites",
    "body": "Say that you place a number of bets on your favorite sports teams.  If their chances of winning are 0.3, 0.8, and 0.6, then you should expect on average to win 0.3 + 0.8 + 0.6 = 1.7 of your bets (of course, you can never win exactly 1.7!)\nMore generally, if we have a collection of events A_1, A_2, \\ldots, A_n, then the expected number of events occurring is \\mathrm{Pr}(A_1) + \\mathrm{Pr}(A_2) + \\cdots + \\mathrm{Pr}(A_n) (consult the note following the problem for a precise explanation of this fact). In this problem, we extend the idea of finding an expected number of events to finding the expected number of times that a given string occurs as a substring of a random string.\nGiven: A positive integer n (n \\leq 1,000,000), a DNA string s of even length at most 10, and an array A of length at most 20, containing numbers between 0 and 1.\nReturn:  An array B having the same length as A in which B[i] represents the expected number of times that s will appear as a substring of a random DNA string t of length n, where t is formed with GC-content A[i] (see \u201cIntroduction to Random Strings\u201d).\nIn this problem, we are speaking of an expected number of events; how can we tie this into the definition of expected value that we already have from \u201cCalculating Expected Offspring\u201d?\nThe answer relies on a slick mathematical trick. For any event A, we can form a random variable for A, called an indicator random variable I_{A}.  For an outcome x, I_{A}(x) = 1 when x belongs to A and I_{A}(x) = 0 when x belongs to A^{\\textrm{c}}.\nFor an indicator random variable I_{A}(x) = 1, verify that \\mathrm{E}(I_{A}) = \\mathrm{Pr}(A).\nYou should also verify from our original formula for expected value that for any two random variables X and Y, \\mathrm{E}(X + Y) is equal to \\mathrm{E}(X) + \\mathrm{E}(Y). As a result, the expected number of events A_1, A_2, \\ldots, A_m occurring, or \\mathrm{E}(I_{A_1} + I_{A_2} + \\cdots + I_{A_m}), reduces to \\mathrm{Pr}(A_1) + \\mathrm{Pr}(A_2) + \\cdots + \\mathrm{Pr}(A_m).\n",
    "data": "10\nAG\n0.25 0.5 0.75",
    "output": "0.422 0.563 0.422",
    "topics": "Probability"
  },
  "('48', 'MOTZ')": {
    "className": "Problem",
    "moduleName": "model.Problem",
    "num": 48,
    "id": "MOTZ",
    "title": "Motzkin Numbers and RNA Secondary Structures",
    "body": "Similarly to our definition of the Catalan numbers, the n-th Motzkin number m_n counts the number of ways to form a (not necessarily perfect) noncrossing matching in the complete graph K_n containing n nodes. For example, Figure 1 demonstrates that m_5 = 21.  Note in this figure that technically, the \"trivial\" matching that contains no edges at all is considered to be a matching, because it satisfies the defining condition that no two edges are incident to the same node.\nHow should we compute the Motzkin numbers?  As with Catalan numbers, we will take m_0 = m_1 = 1. To calculate m_n in general, assume that the nodes of K_n are labeled around the outside of a circle with the integers between 1 and n, and consider node 1, which may or may not be involved in a matching. If node 1 is not involved in a matching, then there are m_{n-1} ways of matching the remaining n - 1 nodes. If node 1 is involved in a matching, then say it is matched to node k: this leaves k - 2 nodes on one side of edge \\{1, k\\} and n - k nodes on the other side; as with the Catalan numbers, no edge can connect the two sides, which gives us m_{k-2} \\cdot m_{n-k} ways of matching the remaining edges. Allowing k to vary between 2 and n yields the following recurrence relation for the Motzkin numbers: m_n = m_{n-1} + \\sum_{k = 2}^{n}{m_{k-2} \\cdot m_{n-k}}.\nTo count all possible secondary structures of a given RNA string that do not contain pseudoknots, we need to modify the Motzkin recurrence so that it counts only matchings of basepair edges in the bonding graph corresponding to the RNA string; see Figure 2.\nGiven: An RNA string s of length at most 300 bp.\nReturn: The total number of noncrossing matchings of basepair edges in the bonding graph of s, modulo 1,000,000.\n",
    "data": ">Rosalind_57\nAUAU",
    "output": "7",
    "topics": "Combinatorics, Dynamic Programming, String Algorithms"
  },
  "('49', 'NWCK')": {
    "className": "Problem",
    "moduleName": "model.Problem",
    "num": 49,
    "id": "NWCK",
    "title": "Distances in Trees",
    "body": "Newick format is a way of representing trees even more concisely than using an adjacency list, especially when dealing with trees whose internal nodes have not been labeled.\nFirst, consider the case of a rooted tree T. A collection of leaves v_1, v_2, \\ldots, v_n of T are neighbors if they are all adjacent to some internal node u.  Newick format for T is obtained by iterating the following key step: delete all the edges \\{v_i, u\\} from T and label u with (v_1, v_2, \\ldots, v_n)u.  This process is repeated all the way to the root, at which point a semicolon signals the end of the tree.\nA number of variations of Newick format exist.  First, if a node is not labeled in T, then we simply leave blank the space occupied by the node.  In the key step, we can write (v_1, v_2, \\ldots, v_n) in place of (v_1, v_2, \\ldots, v_n)u if the v_i are labeled; if none of the nodes are labeled, we can write (, , \\ldots, ).\nA second variation of Newick format occurs when T is unrooted, in which case we simply select any internal node to serve as the root of T.  A particularly peculiar case of Newick format arises when we choose a leaf to serve as the root.\nNote that there will be a large number of different ways to represent T in Newick format; see Figure 1.\nGiven: A collection of n trees (n \\leq 40) in Newick format, with each tree containing at most 200 nodes; each tree T_k is followed by a pair of nodes x_k and y_k in T_k.\nReturn: A collection of n positive integers, for which the kth integer represents the distance between x_k and y_k in T_k.\n",
    "data": "(cat)dog;\ndog cat\n\n(dog,cat);\ndog cat",
    "output": "1 2",
    "topics": "Phylogeny"
  },
  "('50', 'SCSP')": {
    "className": "Problem",
    "moduleName": "model.Problem",
    "num": 50,
    "id": "SCSP",
    "title": "Interleaving Two Motifs",
    "body": "A string s is a supersequence of another string t if s contains t as a subsequence.\nA common supersequence of strings s and t is a string that serves as a supersequence of both s and t.  For example, \"GACCTAGGAACTC\" serves as a common supersequence of \"ACGTC\" and \"ATAT\". A shortest common supersequence of s and t is a supersequence for which there does not exist a shorter common supersequence.  Continuing our example, \"ACGTACT\" is a shortest common supersequence of \"ACGTC\" and \"ATAT\".\nGiven: Two DNA strings s and t.\nReturn: A shortest common supersequence of s and t.  If multiple solutions exist, you may output any one.\n",
    "data": "ATCTGAT\nTGCATA",
    "output": "ATGCATGAT",
    "topics": "Dynamic Programming, String Algorithms"
  },
  "('51', 'SETO')": {
    "className": "Problem",
    "moduleName": "model.Problem",
    "num": 51,
    "id": "SETO",
    "title": "Introduction to Set Operations",
    "body": "If A and B are sets, then their union A \\cup B is the set comprising any elements in either A or B; their intersection A \\cap B is the set of elements in both A and B; and their set difference A - B is the set of elements in A but not in B.\nFurthermore, if A is a subset of another set U, then the set complement of A with respect to U is defined as the set A^{\\textrm{c}} = U - A.  See the Sample sections below for examples.\nGiven: A positive integer n (n \\leq 20,000) and two subsets A and B of \\{1, 2, \\ldots, n\\}.\nReturn: Six sets: A \\cup B, A \\cap B, A - B, B - A, A^{\\textrm{c}}, and B^{\\textrm{c}} (where set complements are taken with respect to \\{1, 2, \\ldots, n\\}).\nFrom the definitions above, one can see that A \\cup B = B \\cup A and A \\cap B = B \\cap A for all sets A and B, but it is not necessarily the case that A - B = B - A (as seen in the Sample sections above). This set theoretical fact parallels the arithmetical fact that addition is commutative but subtraction is not.\n",
    "data": "10\n{1, 2, 3, 4, 5}\n{2, 8, 5, 10}",
    "output": "{1, 2, 3, 4, 5, 8, 10}\n{2, 5}\n{1, 3, 4}\n{8, 10}\n{8, 9, 10, 6, 7}\n{1, 3, 4, 6, 7, 9}",
    "topics": "Set Theory"
  },
  "('52', 'SORT')": {
    "className": "Problem",
    "moduleName": "model.Problem",
    "num": 52,
    "id": "SORT",
    "title": "Sorting by Reversals",
    "body": "A reversal of a permutation can be encoded by the two indices at the endpoints of the interval that it inverts; for example, the reversal that transforms (4, 1, 2, 6, 3, 5) into (4, 1, 3, 6, 2, 5) is encoded by [3, 5].\nA collection of reversals sorts \\pi into \\gamma if the collection contains d_{\\textrm{rev}}(\\pi, \\gamma) reversals, which when successively applied to \\pi yield \\gamma.\nGiven: Two permutations \\pi and \\gamma, each of length 10.\nReturn: The reversal distance d_{\\textrm{rev}}(\\pi, \\gamma), followed by a collection of reversals sorting \\pi into \\gamma.  If multiple collections of such reversals exist, you may return any one.\n",
    "data": "1 2 3 4 5 6 7 8 9 10\n1 8 9 3 2 7 6 5 4 10",
    "output": "2\n4 9\n2 5",
    "topics": "Combinatorics, Genome Rearrangements"
  },
  "('53', 'SPEC')": {
    "className": "Problem",
    "moduleName": "model.Problem",
    "num": 53,
    "id": "SPEC",
    "title": "Inferring Protein from Spectrum",
    "body": "The prefix spectrum of a weighted string is the collection of all its prefix weights.\nGiven: A list L of n (n \\leq 100) positive real numbers.\nReturn: A protein string of length n-1 whose prefix spectrum is equal to L (if multiple solutions exist, you may output any one of them).  Consult the monoisotopic mass table.\n",
    "data": "3524.8542\n3710.9335\n3841.974\n3970.0326\n4057.0646",
    "output": "WMQS",
    "topics": "Computational Mass Spectrometry"
  },
  "('54', 'TRIE')": {
    "className": "Problem",
    "moduleName": "model.Problem",
    "num": 54,
    "id": "TRIE",
    "title": "Introduction to Pattern Matching",
    "body": "Given a collection of strings, their trie (often pronounced \"try\" to avoid ambiguity with the general term tree) is a rooted tree formed as follows.  For every unique first symbol in the strings, an edge is formed connecting the root to a new vertex.  This symbol is then used to label the edge.\nWe may then iterate the process by moving down one level as follows.  Say that an edge connecting the root to a node v is labeled with 'A'; then we delete the first symbol from every string in the collection beginning with 'A' and then treat v as our root.  We apply this process to all nodes that are adjacent to the root, and then we move down another level and continue. See Figure 1 for an example of a trie.\nAs a result of this method of construction, the symbols along the edges of any path in the trie from the root to a leaf will spell out a unique string from the collection, as long as no string is a prefix of another in the collection (this would cause the first string to be encoded as a path terminating at an internal node).\nGiven: A list of at most 100 DNA strings of length at most 100 bp, none of which is a prefix of another.\nReturn: The adjacency list corresponding to the trie T for these patterns, in the following format. If T has n nodes, first label the root with 1 and then label the remaining nodes with the integers 2 through n in any order you like.  Each edge of the adjacency list of T will be encoded by a triple containing the integer representing the edge's parent node, followed by the integer representing the edge's child node, and finally the symbol labeling the edge.\n",
    "data": "ATAGA\nATC\nGAT",
    "output": "1 2 A\n2 3 T\n3 4 A\n4 5 G\n5 6 A\n3 7 C\n1 8 G\n8 9 A\n9 10 T",
    "topics": "Graph Algorithms, String Algorithms"
  },
  "('55', 'CONV')": {
    "className": "Problem",
    "moduleName": "model.Problem",
    "num": 55,
    "id": "CONV",
    "title": "Comparing Spectra with the Spectral Convolution",
    "body": "A multiset is a generalization of the notion of set to include a collection of objects in which each object may occur more than once (the order in which objects are given is still unimportant).  For a multiset S, the multiplicity of an element x is the number of times that x occurs in the set; this multiplicity is denoted S(x). Note that every set is included in the definition of multiset.\nThe Minkowski sum of multisets S_1 and S_2 containing real numbers is the new multiset S_1 \\oplus S_2 formed by taking all possible sums s_1 + s_2 of an element s_1 from S_1 and an element s_2 from S_2. The Minkowski sum could be defined more concisely as S_1 \\oplus S_2 = {s_1 + s_2 : s_1 \\in S_1, s_2 \\in S_2}, The Minkowski difference S_1 \\ominus S_2 is defined analogously by taking all possible differences s_1 - s_2.\nIf S_1 and S_2 represent simplified spectra taken from two peptides, then S_1 \\ominus S_2 is called the spectral convolution of S_1 and S_2.  In this notation, the shared peaks count is represented by (S_2 \\ominus S_1)(0), and the value of x for which (S_2 \\ominus S_1)(x) has the maximal value is the shift value maximizing the number of shared masses of S_1 and S_2.\nGiven: Two multisets of positive real numbers S_1 and S_2. The size of each multiset is at most 200.\nReturn: The largest multiplicity of S_1 \\ominus S_2, as well as the absolute value of the number x maximizing (S_1 \\ominus S_2)(x) (you may return any such value if multiple solutions exist).\nObserve that S_1 \\oplus S_2 is equivalent to S_2 \\oplus S_1, but it is not usually the case that S_1 \\ominus S_2 is the same as S_2 \\ominus S_1; in this case, one multiset can be obtained from the other by negating every element.\n",
    "data": "186.07931 287.12699 548.20532 580.18077 681.22845 706.27446 782.27613 968.35544 968.35544\n101.04768 158.06914 202.09536 318.09979 419.14747 463.17369",
    "output": "3\n85.03163",
    "topics": "Computational Mass Spectrometry"
  },
  "('56', 'CTBL')": {
    "className": "Problem",
    "moduleName": "model.Problem",
    "num": 56,
    "id": "CTBL",
    "title": "Creating a Character Table",
    "body": "Given a collection of n taxa, any subset S of these taxa can be seen as encoding a character that divides the taxa into the sets S and S^{\\textrm{c}}; we can represent the character by S \\mid S^{\\textrm{c}}, which is called a split. Alternately, the character can be represented by a character array A of length n for which A[j] = 1 if the jth taxon belongs to S and A[j] = 0 if the jth taxon belongs to S^{\\textrm{c}} (recall the \"ON\"/\"OFF\" analogy from \u201cCounting Subsets\u201d).\nAt the same time, observe that the removal of an edge from an unrooted binary tree produces two separate trees, each one containing a subset of the original taxa.  So each edge may also be encoded by a split S \\mid S^{\\textrm{c}}.\nA trivial character isolates a single taxon into a group of its own. The corresponding split S \\mid S^{\\textrm{c}} must be such that S or S^{\\textrm{c}} contains only one element; the edge encoded by this split must be incident to a leaf of the unrooted binary tree, and the array for the character contains exactly one 0 or exactly one 1.  Trivial characters are of no phylogenetic interest because they fail to provide us with information regarding the relationships of taxa to each other. All other characters are called nontrivial characters (and the associated splits are called nontrivial splits).\nA character table is a matrix C in which each row represents the array notation for a nontrivial character. That is, entry C_{i,j} denotes the \"ON\"/\"OFF\" position of the ith character with respect to the jth taxon.\nGiven: An unrooted binary tree T in Newick format for at most 200 species taxa.\nReturn: A character table having the same splits as the edge splits of T. The columns of the character table should encode the taxa ordered lexicographically; the rows of the character table may be given in any order.  Also, for any given character, the particular subset of taxa to which 1s are assigned is arbitrary.\n",
    "data": "(dog,((elephant,mouse),robot),cat);",
    "output": "00110\n00111",
    "topics": "Phylogeny"
  },
  "('57', 'DBRU')": {
    "className": "Problem",
    "moduleName": "model.Problem",
    "num": 57,
    "id": "DBRU",
    "title": "Constructing a De Bruijn Graph",
    "body": "Consider a set S of (k+1)-mers of some unknown DNA string.  Let S^{\\textrm{rc}} denote the set containing all reverse complements of the elements of S. (recall from \u201cCounting Subsets\u201d that sets are not allowed to contain duplicate elements).\nThe de Bruijn graph B_k of order k corresponding to S \\cup S^{\\textrm{rc}} is a digraph defined in the following way:\nGiven: A collection of up to 1000 (possibly repeating) DNA strings of equal length (not exceeding 50 bp) corresponding to a set S of (k+1)-mers.\nReturn: The adjacency list corresponding to the de Bruijn graph corresponding to S \\cup S^{\\textrm{rc}}.\n",
    "data": "TGAT\nCATG\nTCAT\nATGC\nCATC\nCATC",
    "output": "(ATC, TCA)\n(ATG, TGA)\n(ATG, TGC)\n(CAT, ATC)\n(CAT, ATG)\n(GAT, ATG)\n(GCA, CAT)\n(TCA, CAT)\n(TGA, GAT)",
    "topics": "Genome Assembly"
  },
  "('58', 'EDTA')": {
    "className": "Problem",
    "moduleName": "model.Problem",
    "num": 58,
    "id": "EDTA",
    "title": "Edit Distance Alignment",
    "body": "An alignment of two strings s and t is defined by two strings s' and t' satisfying the following three conditions: 1. s' and t' must be formed from adding gap symbols \"-\" to each of s and t, respectively; as a result, s and t will form subsequences of s' and t'. 2. s' and t' must have the same length. 3. Two gap symbols may not be aligned; that is, if s'[j] is a gap symbol, then t'[j] cannot be a gap symbol, and vice-versa.\nWe say that s' and t' augment s and t.  Writing s' directly over t' so that symbols are aligned provides us with a scenario for transforming s into t. Mismatched symbols from s and t correspond to symbol substitutions; a gap symbol s'[j] aligned with a non-gap symbol t'[j] implies the insertion of this symbol into t; a gap symbol t'[j]  aligned with a non-gap symbol s'[j] implies the deletion of this symbol from s.\nThus, an alignment represents a transformation of s into t via edit operations. We define the corresponding edit alignment score of s' and t' as d_{\\textrm{H}}(s', t') (Hamming distance is used because the gap symbol has been introduced for insertions and deletions). It follows that d_{\\textrm{E}}(s, t) = \\min_{s', t'}{d_{\\textrm{H}}(s', t')}, where the minimum is taken over all alignments of s and t.  We call such a minimum score alignment an optimal alignment (with respect to edit distance).\nGiven: Two protein strings s and t in FASTA format (with each string having length at most 1000 aa).\nReturn: The edit distance d_{\\textrm{E}}(s, t) followed by two augmented strings s' and t' representing an optimal alignment of s and t.\n",
    "data": ">Rosalind_43\nPRETTY\n>Rosalind_97\nPRTTEIN",
    "output": "4\nPRETTY--\nPR-TTEIN",
    "topics": "Alignment, Dynamic Programming"
  },
  "('59', 'FULL')": {
    "className": "Problem",
    "moduleName": "model.Problem",
    "num": 59,
    "id": "FULL",
    "title": "Inferring Peptide from Full Spectrum",
    "body": "Say that we have a string s containing t as an internal substring, so that there exist nonempty substrings s_1 and s_2 of s such that s can be written as s_1 t s_2. A t-prefix contains all of s_1 and none of s_2; likewise, a t-suffix contains all of s_2 and none of s_1.\nGiven: A list L containing 2n + 3 positive real numbers (n \\leq 100). The first number in L is the parent mass of a peptide P, and all other numbers represent the masses of some b-ions and y-ions of P (in no particular order). You may assume that if the mass of a b-ion is present, then so is that of its complementary y-ion, and vice-versa.\nReturn: A protein string t of length n for which there exist two positive real numbers w_1 and w_2 such that for every prefix p and suffix s of t, each of w(p) + w_1 and w(s) + w_2 is equal to an element of L.  (In other words, there exists a protein string whose t-prefix and t-suffix weights correspond to the non-parent mass values of L.)  If multiple solutions exist, you may output any one.\n",
    "data": "1988.21104821\n610.391039105\n738.485999105\n766.492149105\n863.544909105\n867.528589105\n992.587499105\n995.623549105\n1120.6824591\n1124.6661391\n1221.7188991\n1249.7250491\n1377.8200091",
    "output": "KEKEP",
    "topics": "Computational Mass Spectrometry"
  },
  "('60', 'INDC')": {
    "className": "Problem",
    "moduleName": "model.Problem",
    "num": 60,
    "id": "INDC",
    "title": "Independent Segregation of Chromosomes",
    "body": "Consider a collection of coin flips.  One of the most natural questions we can ask is if we flip a coin 92 times, what is the probability of obtaining 51 \"heads\", vs. 27 \"heads\", vs. 92 \"heads\"?\nEach coin flip can be modeled by a uniform random variable in which each of the two outcomes (\"heads\" and \"tails\") has probability equal to 1/2.  We may assume that these random variables are independent (see \u201cIndependent Alleles\u201d); in layman's terms, the outcomes of the two coin flips do not influence each other.\nA binomial random variable X takes a value of k if n consecutive \"coin flips\" result in k total \"heads\" and n-k total \"tails.\" We write that X \\in \\mathrm{Bin}(n, 1/2).\nGiven: A positive integer n \\leq 50.\nReturn: An array A of length 2n in which A[k] represents the common logarithm of the probability that two diploid siblings share at least k of their 2n chromosomes (we do not consider recombination for now).\n",
    "data": "5",
    "output": "0.000 -0.004 -0.024 -0.082 -0.206 -0.424 -0.765 -1.262 -1.969 -3.010",
    "topics": "Heredity, Probability"
  },
  "('61', 'ITWV')": {
    "className": "Problem",
    "moduleName": "model.Problem",
    "num": 61,
    "id": "ITWV",
    "title": "Finding Disjoint Motifs in a Gene",
    "body": "Given three strings s, t, and u, we say that t and u can be interwoven into s if there is some substring of s made up of t and u as disjoint subsequences.\nFor example, the strings \"\\color{blue}\\text{ACAG}\" and \"\\color{red}\\text{CCG}\" can be interwoven into \"\\color{black}\\text{G}\\color{blue}\\text{A}\\color{red}\\text{C}\\color{blue}\\text{CA}\\color{red}\\text{C}\\color{blue}\\text{G}\\color{red}\\text{G}\\color{black}\\text{TT}\". However, they cannot be interwoven into \"\\color{black}\\text{G}\\color{blue}\\text{A}\\color{red}\\text{C}\\color{blue}\\text{CA}\\color{red}\\text{C}\\color{black}\\text{AAAA}\\color{blue}\\text{G}\\color{red}\\text{G}\\color{black}\\text{TT}\" because of the appearance of the four 'A's in the middle of the subsequences. Similarly, even though both \"\\textrm{ACACG}\" is a shortest common supersequence of \\textrm{ACAG} and \\textrm{CCG}, it is not possible to interweave these two strings into \"\\textrm{ACACG}\" because the two desired subsequences must be disjoint; see \u201cInterleaving Two Motifs\u201d for details on finding a shortest common supersequence of two strings.\nGiven: A text DNA string s of length at most 10 kbp, followed by a collection of n (n \\leq 10) DNA strings of length at most 10 bp acting as patterns.\nReturn: An n \\times n matrix M for which M_{j, k} = 1 if the jth and kth pattern strings can be interwoven into s and M_{j, k} = 0 otherwise.\nThis problem follows Jones & Pevzner, An Introduction to Bioinformatics Algorithms, Problem 6.31\n",
    "data": "GACCACGGTT\nACAG\nGT\nCCG",
    "output": "0 0 1\n0 1 0\n1 0 0",
    "topics": "Dynamic Programming, String Algorithms"
  },
  "('62', 'LREP')": {
    "className": "Problem",
    "moduleName": "model.Problem",
    "num": 62,
    "id": "LREP",
    "title": "Finding the Longest Multiple Repeat",
    "body": "A repeated substring of a string s of length n is simply a substring that appears in more than one location of s; more specifically, a k-fold substring appears in at least k distinct locations.\nThe suffix tree of s, denoted T(s), is defined as follows:\nSee Figure 1 for an example of a suffix tree.\nGiven: A DNA string s (of length at most 20 kbp) with  appended, a positive integer k, and a list of edges defining the suffix tree of s. Each edge is represented by four components:\nReturn: The longest substring of s that occurs at least k times in s. (If multiple solutions exist, you may return any single solution.)\nHow can repeated substrings of s be located in T(s)?\n",
    "data": "CATACATAC$\n2\nnode1 node2 1 1\nnode1 node7 2 1\nnode1 node14 3 3\nnode1 node17 10 1\nnode2 node3 2 4\nnode2 node6 10 1\nnode3 node4 6 5\nnode3 node5 10 1\nnode7 node8 3 3\nnode7 node11 5 1\nnode8 node9 6 5\nnode8 node10 10 1\nnode11 node12 6 5\nnode11 node13 10 1\nnode14 node15 6 5\nnode14 node16 10 1",
    "output": "CATAC",
    "topics": "Graph Algorithms"
  },
  "('63', 'NKEW')": {
    "className": "Problem",
    "moduleName": "model.Problem",
    "num": 63,
    "id": "NKEW",
    "title": "Newick Format with Edge Weights",
    "body": "In a weighted tree, each edge is assigned a (usually positive) number, called its weight.  The distance between two nodes in a weighted tree becomes the sum of the weights along the unique path connecting the nodes.\nTo generalize Newick format to the case of a weighted tree T, during our repeated \"key step,\" if leaves v_1, v_2, \\ldots, v_n are neighbors in T, and all these leaves are incident to u, then we replace u with (v_1:d_1, v_2:d_2, \\ldots, v_n:d_n)u, where d_i is now the weight on the edge \\{v_i, u\\}.\nGiven: A collection of n weighted trees (n \\leq 40) in Newick format, with each tree containing at most 200 nodes; each tree T_k is followed by a pair of nodes x_k and y_k in T_k.\nReturn: A collection of n numbers, for which the kth number represents the distance between x_k and y_k in T_k.\n",
    "data": "(dog:42,cat:33);\ncat dog\n\n((dog:4,cat:3):74,robot:98,elephant:58);\ndog elephant",
    "output": "75 136",
    "topics": "Phylogeny"
  },
  "('64', 'RNAS')": {
    "className": "Problem",
    "moduleName": "model.Problem",
    "num": 64,
    "id": "RNAS",
    "title": "Wobble Bonding and RNA Secondary Structures",
    "body": "Given an RNA string s, we will augment the bonding graph of s by adding basepair edges connecting all occurrences of 'U' to all occurrences of 'G' in order to represent possible wobble base pairs.\nWe say that a matching in the bonding graph for s is valid if it is noncrossing (to prevent pseudoknots) and has the property that a basepair edge in the matching cannot connect symbols s_j and s_k unless k \\geq j+4 (to prevent nearby nucleotides from base pairing).\nSee Figure 1 for an example of a valid matching if we allow wobble base pairs.  In this problem, we will wish to count all possible valid matchings in a given bonding graph; see Figure 2 for all possible valid matchings in a small bonding graph, assuming that we allow wobble base pairing.\nGiven: An RNA string s (of length at most 200 bp).\nReturn: The total number of distinct valid matchings of basepair edges in the bonding graph of s. Assume that wobble base pairing is allowed.\n",
    "data": "AUGCUAGUACGGAGCGAGUCUAGCGAGCGAUGUCGUGAGUACUAUAUAUGCGCAUAAGCCACGU",
    "output": "284850219977421",
    "topics": "Combinatorics, Dynamic Programming, Graph Algorithms"
  },
  "('65', 'AFRQ')": {
    "className": "Problem",
    "moduleName": "model.Problem",
    "num": 65,
    "id": "AFRQ",
    "title": "Counting Disease Carriers",
    "body": "To model the Hardy-Weinberg principle, assume that we have a population of N diploid individuals. If an allele is in genetic equilibrium, then because mating is random, we may view the 2N chromosomes as receiving their alleles uniformly. In other words, if there are m dominant alleles, then the probability of a selected chromosome exhibiting the dominant allele is simply p = \\frac{m}{2N}.\nBecause the first assumption of genetic equilibrium states that the population is so large as to be ignored, we will assume that N is infinite, so that we only need to concern ourselves with the value of p.\nGiven: An array A for which A[k] represents the proportion of homozygous recessive individuals for the k-th Mendelian factor in a diploid population. Assume that the population is in genetic equilibrium for all factors.\nReturn: An array B having the same length as A in which B[k] represents the probability that a randomly selected individual carries at least one copy of the recessive allele for the k-th factor.\n",
    "data": "0.1 0.25 0.5",
    "output": "0.532 0.75 0.914",
    "topics": "Population Dynamics, Probability"
  },
  "('66', 'CSTR')": {
    "className": "Problem",
    "moduleName": "model.Problem",
    "num": 66,
    "id": "CSTR",
    "title": "Creating a Character Table from Genetic Strings",
    "body": "A collection of strings is characterizable if there are at most two possible choices for the symbol at each position of the strings.\nGiven: A collection of at most 100 characterizable DNA strings, each of length at most 300 bp.\nReturn: A character table for which each nontrivial character encodes the symbol choice at a single position of the strings.  (Note: the choice of assigning '1' and '0' to the two states of each SNP in the strings is arbitrary.)\nRecall that the character table does not encode trivial characters.\n",
    "data": "ATGCTACC\nCGTTTACC\nATTCGACC\nAGTCTCCC\nCGTCTATC",
    "output": "10110\n10100",
    "topics": "Phylogeny"
  },
  "('67', 'CTEA')": {
    "className": "Problem",
    "moduleName": "model.Problem",
    "num": 67,
    "id": "CTEA",
    "title": "Counting Optimal Alignments",
    "body": "Recall from \u201cEdit Distance Alignment\u201d that if s' and t' are the augmented strings corresponding to an alignment of strings s and t, then the edit alignment score of s' and t' was given by the Hamming distance d_{\\textrm{H}}(s', t') (because s' and t' have the same length and already include gap symbols to denote insertions/deletions).\nAs a result, we obtain d_{\\textrm{E}}(s, t) = \\min_{s', t'}{d_{\\textrm{H}}(s', t')}, where the minimum is taken over all alignments of s and t.  Strings s' and t' achieving this minimum correspond to an optimal alignment with respect to edit alignment score.\nGiven: Two protein strings s and t in FASTA format, each of length at most 1000 aa.\nReturn: The total number of optimal alignments of s and t with respect to edit alignment score, modulo 134,217,727 (227-1).\nAs a simple example, say that we attempt to count some statistic modulo 10. If computing the statistic requires us to multiply a collection of integers, and at any point we multiply by a multiple of 10, then the statistic will automatically become a multiple of 10 and thus congruent to 0 modulo 10. A similar issue can arise when we count a huge number modulo any composite number; however, if we count modulo a large prime number p (i.e., one without any divisors other than itself), then problems can only ever arise if when counting our statistic, we multiply by a multiple of p.\n",
    "data": ">Rosalind_78\nPLEASANTLY\n>Rosalind_33\nMEANLY",
    "output": "4",
    "topics": "Alignment, Combinatorics"
  },
  "('68', 'CUNR')": {
    "className": "Problem",
    "moduleName": "model.Problem",
    "num": 68,
    "id": "CUNR",
    "title": "Counting Unrooted Binary Trees",
    "body": "Two unrooted binary trees T_1 and T_2 having the same n labeled leaves are considered to be equivalent if there is some assignment of labels to the internal nodes of T_1 and T_2 so that the adjacency lists of the two trees coincide. As a result, note that T_1 and T_2 must have the same splits; conversely, if the two trees do not have the same splits, then they are considered distinct.\nLet b(n) denote the total number of distinct unrooted binary trees having n labeled leaves.\nGiven: A positive integer n (n \\leq 1000).\nReturn: The value of b(n) modulo 1,000,000.\n",
    "data": "5",
    "output": "15",
    "topics": "Combinatorics, Phylogeny"
  },
  "('69', 'GLOB')": {
    "className": "Problem",
    "moduleName": "model.Problem",
    "num": 69,
    "id": "GLOB",
    "title": "Global Alignment with Scoring Matrix",
    "body": "To penalize symbol substitutions differently depending on which two symbols are involved in the substitution, we obtain a scoring matrix S in which S_{i, j} represents the (negative) score assigned to a substitution of the ith symbol of our alphabet \\mathscr{A} with the jth symbol of \\mathscr{A}.\nA gap penalty is the component deducted from alignment score due to the presence of a gap. A gap penalty may be a function of the length of the gap; for example, a linear gap penalty is a constant g such that each inserted or deleted symbol is charged g; as a result, the cost of a gap of length L is equal to gL.\nGiven: Two protein strings s and t in FASTA format (each of length at most 1000 aa).\nReturn: The maximum alignment score between s and t. Use:\n",
    "data": ">Rosalind_67\nPLEASANTLY\n>Rosalind_17\nMEANLY",
    "output": "8",
    "topics": "Alignment, Dynamic Programming"
  },
  "('70', 'PCOV')": {
    "className": "Problem",
    "moduleName": "model.Problem",
    "num": 70,
    "id": "PCOV",
    "title": "Genome Assembly with Perfect Coverage",
    "body": "A circular string is a string that does not have an initial or terminal element; instead, the string is viewed as a necklace of symbols.  We can represent a circular string as a string enclosed in parentheses.  For example, consider the circular DNA string (ACGTAC), and note that because the string \"wraps around\" at the end, this circular string can equally be represented by (CGTACA), (GTACAC), (TACACG), (ACACGT), and (CACGTA).  The definitions of substrings and superstrings are easy to generalize to the case of circular strings (keeping in mind that substrings are allowed to wrap around).\nGiven: A collection of (error-free) DNA k-mers (k \\leq 50) taken from the same strand of a circular chromosome. In this dataset, all k-mers from this strand of the chromosome are present, and their de Bruijn graph consists of exactly one simple cycle.\nReturn: A cyclic superstring of minimal length containing the reads (thus corresponding to a candidate cyclic chromosome).\nThe assumption made above that all reads derive from the same strand is practically unrealistic; in reality, researchers will not know the strand of DNA from which a given read has been sequenced.\n",
    "data": "ATTAC\nTACAG\nGATTA\nACAGA\nCAGAT\nTTACA\nAGATT",
    "output": "GATTACA",
    "topics": "Genome Assembly, Graph Algorithms"
  },
  "('71', 'PRSM')": {
    "className": "Problem",
    "moduleName": "model.Problem",
    "num": 71,
    "id": "PRSM",
    "title": "Matching a Spectrum to a Protein",
    "body": "The complete spectrum of a weighted string s is the multiset S[s] containing the weights of every prefix and suffix of s.\nGiven: A positive integer n followed by a collection of n protein strings s_1, s_2, ..., s_n and a multiset R of positive numbers (corresponding to the complete spectrum of some unknown protein string).\nReturn: The maximum multiplicity of R \\ominus S[s_k] taken over all strings s_k, followed by the string s_k for which this maximum multiplicity occurs (you may output any such value if multiple solutions exist).\n",
    "data": "4\nGSDMQS\nVWICN\nIASWMQS\nPVSMGAD\n445.17838\n115.02694\n186.07931\n314.13789\n317.1198\n215.09061",
    "output": "3\nIASWMQS",
    "topics": "Computational Mass Spectrometry"
  },
  "('72', 'QRT')": {
    "className": "Problem",
    "moduleName": "model.Problem",
    "num": 72,
    "id": "QRT",
    "title": "Quartets",
    "body": "A partial split of a set S of n taxa models a partial character and is denoted by A \\mid B, where A and B are still the two disjoint subsets of taxa divided by the character. Unlike in the case of splits, we do not necessarily require that A \\cup B = S; (A \\cup B)^{\\textrm{c}} corresponds to those taxa for which we lack conclusive evidence regarding the character.\nWe can assemble a collection of partial characters into a generalized partial character table C in which the symbol x is placed in C_{i, j} if we do not have conclusive evidence regarding the jth taxon with respect to the ith partial character.\nA quartet is a partial split A \\mid B in which both A and B contain precisely two elements. For the sake of simplicity, we often will consider quartets instead of partial characters. We say that a quartet A \\mid B is inferred from a partial split C \\mid D if A \\subseteq C and B \\subseteq D (or equivalently A \\subseteq D and B \\subseteq C).  For example, \\{1, 3\\} \\mid \\{2, 4\\}  and \\{3, 5\\} \\mid \\{2, 4\\} can be inferred from \\{1, 3, 5\\} \\mid \\{2, 4\\}.\nGiven: A partial character table C.\nReturn: The collection of all quartets that can be inferred from the splits corresponding to the underlying characters of C.\n",
    "data": "cat dog elephant ostrich mouse rabbit robot\n01xxx00\nx11xx00\n111x00x",
    "output": "{elephant, dog} {rabbit, robot}\n{cat, dog} {mouse, rabbit}\n{mouse, rabbit} {cat, elephant}\n{dog, elephant} {mouse, rabbit}",
    "topics": "Phylogeny"
  },
  "('73', 'SGRA')": {
    "className": "Problem",
    "moduleName": "model.Problem",
    "num": 73,
    "id": "SGRA",
    "title": "Using the Spectrum Graph to Infer Peptides",
    "body": "For a weighted alphabet \\mathscr{A} and a collection L of positive real numbers, the spectrum graph of L is a digraph constructed in the following way.  First, create a node for every real number in L.  Then, connect a pair of nodes with a directed edge (u, v) if v > u and v - u is equal to the weight of a single symbol in \\mathscr{A}.  We may then label the edge with this symbol.\nIn this problem, we say that a weighted string s = s_1 s_2 \\cdots s_n matches L if there is some increasing sequence of positive real numbers (w_1, w_2, \\ldots, w_{n+1}) in L such that w(s_1) = w_2 - w_1,  w(s_2) = w_3 - w_2, ..., and w(s_n) = w_{n+1} - w_{n}.\nGiven: A list L (of length at most 100) containing positive real numbers.\nReturn: The longest protein string that matches the spectrum graph of L (if multiple solutions exist, you may output any one of them).  Consult the monoisotopic mass table.\nHow can our question be rephrased in terms of the spectrum graph?\n",
    "data": "3524.8542\n3623.5245\n3710.9335\n3841.974\n3929.00603\n3970.0326\n4026.05879\n4057.0646\n4083.08025",
    "output": "WMSPG",
    "topics": "Computational Mass Spectrometry, Graph Algorithms"
  },
  "('74', 'SUFF')": {
    "className": "Problem",
    "moduleName": "model.Problem",
    "num": 74,
    "id": "SUFF",
    "title": "Encoding Suffix Trees",
    "body": "Given a string s having length n, recall that its suffix tree T(s) is defined by the following properties:\nFigure 1 contains an example of a suffix tree.\nGiven: A DNA string s of length at most 1kbp.\nReturn: The substrings of s^* encoding the edges of the suffix tree for s.  You may list these substrings in any order.\n",
    "data": "ATAAATG$",
    "output": "AAATG$\nG$\nT\nATG$\nTG$\nA\nA\nAAATG$\nG$\nT\nG$\n$",
    "topics": "Graph Algorithms, String Algorithms"
  },
  "('75', 'CHBP')": {
    "className": "Problem",
    "moduleName": "model.Problem",
    "num": 75,
    "id": "CHBP",
    "title": "Character-Based Phylogeny",
    "body": "Because a tree having n nodes has n-1 edges (see \u201cCompleting a Tree\u201d), removing a single edge from a tree will produce two smaller, disjoint trees.  Recall from \u201cCreating a Character Table\u201d that for this reason, each edge of an unrooted binary tree corresponds to a split S \\mid S^{\\textrm{c}}, where S is a subset of the taxa.\nA consistent character table is one whose characters' splits do not conflict with the edge splits of some unrooted binary tree T on the n taxa. More precisely, S_1 \\mid S_1^{\\textrm{c}} conflicts with S_2 \\mid S_2^{\\textrm{c}} if all four intersections S_1 \\cap S_2, S_1 \\cap S_2^{\\textrm{c}}, S_1^{\\textrm{c}} \\cap S_2, and S_1^{\\textrm{c}} \\cap S_2^{\\textrm{c}} are nonempty. As a simple example, consider the conflicting splits \\{a, b\\} \\mid \\{c, d\\} and \\{a, c\\} \\mid \\{b, d\\}.\nMore generally, given a consistent character table C, an unrooted binary tree T \"models\" C if the edge splits of T agree with the splits induced from the characters of C.\nGiven: A list of n species (n \\leq 80) and an n-column character table C in which the jth column denotes the jth species.\nReturn: An unrooted binary tree in Newick format that models C.\n",
    "data": "cat dog elephant mouse rabbit rat\n011101\n001101\n001100",
    "output": "(dog,(cat,rabbit),(rat,(elephant,mouse)));",
    "topics": "Phylogeny"
  },
  "('76', 'CNTQ')": {
    "className": "Problem",
    "moduleName": "model.Problem",
    "num": 76,
    "id": "CNTQ",
    "title": "Counting Quartets",
    "body": "A quartet AB \\mid CD is consistent with a binary tree T if the quartet can be inferred from one of the splits of T (see \u201cQuartets\u201d for a description of inferring quartets from splits).\nLet q(T) denote the total number of quartets that are consistent with T.\nGiven: A positive integer n (4 \\leq n \\leq 5000), followed by an unrooted binary tree T in Newick format on n taxa.\nReturn: The value of q(T) modulo 1,000,000.\n",
    "data": "6\n(lobster,(cat,dog),(caterpillar,(elephant,mouse)));",
    "output": "15",
    "topics": "Combinatorics, Phylogeny"
  },
  "('77', 'EUBT')": {
    "className": "Problem",
    "moduleName": "model.Problem",
    "num": 77,
    "id": "EUBT",
    "title": "Enumerating Unrooted Binary Trees",
    "body": "Recall the definition of Newick format from \u201cDistances in Trees\u201d as a way of encoding trees. See Figure 1 for an example of Newick format applied to an unrooted binary tree whose five leaves are labeled (note that the same tree can have multiple Newick representations).\nGiven: A collection of species names representing n taxa.\nReturn: A list containing all unrooted binary trees whose leaves are these n taxa. Trees should be given in Newick format, with one tree on each line; the order of the trees is unimportant.\n",
    "data": "dog cat mouse elephant",
    "output": "(((mouse,cat),elephant))dog;\n(((elephant,mouse),cat))dog;\n(((elephant,cat),mouse))dog;",
    "topics": "Combinatorics, Phylogeny"
  },
  "('78', 'GASM')": {
    "className": "Problem",
    "moduleName": "model.Problem",
    "num": 78,
    "id": "GASM",
    "title": "Genome Assembly Using Reads",
    "body": "A directed cycle is simply a cycle in a directed graph in which the head of one edge is equal to the tail of the next (so that every edge in the cycle is traversed in the same direction).\nFor a set of DNA strings S and a positive integer k, let S_k denote the collection of all possible k-mers of the strings in S.\nGiven: A collection S of (error-free) reads of equal length (not exceeding 50 bp). In this dataset, for some positive integer k, the de Bruijn graph B_k on S_{k+1} \\cup S_{k+1}^{\\textrm{rc}} consists of exactly two directed cycles.\nReturn: A cyclic superstring of minimal length containing every read or its reverse complement.\nThe reads \"AATCT\" and \"TGTAA\" are not present in the answer, but their reverse complements \"AGATT\" and \"TTACA\" are present in the circular string (GATTACA).\n",
    "data": "AATCT\nTGTAA\nGATTA\nACAGA",
    "output": "GATTACA",
    "topics": "Genome Assembly, Graph Algorithms"
  },
  "('79', 'GCON')": {
    "className": "Problem",
    "moduleName": "model.Problem",
    "num": 79,
    "id": "GCON",
    "title": "Global Alignment with Constant Gap Penalty",
    "body": "In a constant gap penalty, every gap receives some predetermined constant penalty, regardless of its length. Thus, the insertion or deletion of 1000 contiguous symbols is penalized equally to that of a single symbol.\nGiven: Two protein strings s and t in FASTA format (each of length at most 1000 aa).\nReturn: The maximum alignment score between s and t. Use:\n",
    "data": ">Rosalind_79\nPLEASANTLY\n>Rosalind_41\nMEANLY",
    "output": "13",
    "topics": "Alignment, Dynamic Programming"
  },
  "('80', 'LING')": {
    "className": "Problem",
    "moduleName": "model.Problem",
    "num": 80,
    "id": "LING",
    "title": "Linguistic Complexity of a Genome",
    "body": "Given a length n string s formed over an alphabet \\mathscr{A} of size a, let the \"substring count\" \\textrm{sub}(s) denote the total number of distinct substrings of s. Furthermore, let the \"maximum substring count\" m(a, n) denote the maximum number of distinct substrings that could appear in a string of length n formed over \\mathscr{A}.\nThe linguistic complexity of s (written \\textrm{lc}(s)) is equal to \\frac{\\textrm{sub}(s)}{m(a, n)}; in other words, \\textrm{lc}(s) represents the percentage of observed substrings of s to the total number that are theoretically possible.  Note that 0 < \\textrm{lc}(s) < 1, with smaller values of \\textrm{lc}(s) indicating that s is more repetitive.\nAs an example, consider the DNA string (a = 4) s = \\textrm{ATTTGGATT}.  In the following table, we demonstrate that \\textrm{lc}(s) = \\frac{35}{40} = 0.875 by considering the number of observed and possible length k substrings of s, which are denoted by \\textrm{sub}_{k}(s) and m(a, k, n), respectively. (Observe that m(a, n) = \\sum_{k=1}^{n}{m(a,k,n)} = 40 and \\textrm{sub}(s)= \\sum_{k=1}^{n}\\textrm{sub}_{k}(s) = 35.)\n   k  \\textrm{sub}_{k}(s)  m(a, k, n)   1  3  4   2  5  8   3  6  7   4  6  6   5  5  5   6  4  4   7  3  3   8  2  2   9  1  1   Total  35  40 \n\n",
    "data": null,
    "output": null,
    "topics": "String Algorithms"
  },
  "('81', 'LOCA')": {
    "className": "Problem",
    "moduleName": "model.Problem",
    "num": 81,
    "id": "LOCA",
    "title": "Local Alignment with Scoring Matrix",
    "body": "A local alignment of two strings s and t is an alignment of substrings r and u of s and t, respectively.  Let \\textrm{opt}(r, u) denote the score of an optimal alignment of r and u with respect to some predetermined alignment score.\nGiven: Two protein strings s and t in FASTA format (each having length at most 1000 aa).\nReturn: A maximum alignment score along with substrings r and u of s and t, respectively, which produce this maximum alignment score (multiple solutions may exist, in which case you may output any one). Use:\n",
    "data": ">Rosalind_80\nMEANLYPRTEINSTRING\n>Rosalind_21\nPLEASANTLYEINSTEIN",
    "output": "23\nLYPRTEINSTRIN\nLYEINSTEIN",
    "topics": "Alignment, Dynamic Programming"
  },
  "('82', 'MEND')": {
    "className": "Problem",
    "moduleName": "model.Problem",
    "num": 82,
    "id": "MEND",
    "title": "Inferring Genotype from a Pedigree",
    "body": "A rooted binary tree can be used to model the pedigree of an individual. In this case, rather than time progressing from the root to the leaves, the tree is viewed upside down with time progressing from an individual's ancestors (at the leaves) to the individual (at the root).\nAn example of a pedigree for a single factor in which only the genotypes of ancestors are given is shown in Figure 1.\nGiven: A rooted binary tree T in Newick format encoding an individual's pedigree for a Mendelian factor whose alleles are A (dominant) and a (recessive).\nReturn: Three numbers between 0 and 1, corresponding to the respective probabilities that the individual at the root of T will exhibit the \"AA\", \"Aa\" and \"aa\" genotypes.\n",
    "data": "((((Aa,aa),(Aa,Aa)),((aa,aa),(aa,AA))),Aa);",
    "output": "0.156 0.5 0.344",
    "topics": "Heredity, Phylogeny, Probability"
  },
  "('83', 'MGAP')": {
    "className": "Problem",
    "moduleName": "model.Problem",
    "num": 83,
    "id": "MGAP",
    "title": "Maximizing the Gap Symbols of an Optimal Alignment",
    "body": "For the computation of an alignment score generalizing the edit alignment score, let m denote the score assigned to matched symbols, d denote the score assigned to mismatched non-gap symbols, and g denote the score assigned a symbol matched to a gap symbol '-' (i.e., g is a linear gap penalty).\nGiven: Two DNA strings s and t in FASTA format (each of length at most 5000 bp).\nReturn: The maximum number of gap symbols that can appear in any maximum score alignment of s and t with score parameters satisfying m > 0, d < 0, and g < 0.\n",
    "data": ">Rosalind_92\nAACGTA\n>Rosalind_47\nACACCTA",
    "output": "3",
    "topics": "Alignment, Dynamic Programming"
  },
  "('84', 'MREP')": {
    "className": "Problem",
    "moduleName": "model.Problem",
    "num": 84,
    "id": "MREP",
    "title": "Identifying Maximal Repeats",
    "body": "A maximal repeat of a string s is a repeated substring t of s having two occurrences t_1 and t_2 such that t_1 and t_2 cannot be extended by one symbol in either direction in s and still agree.\nFor example, \"AG\" is a maximal repeat in \"TAGTTAGCGAGA\" because even though the first two occurrences of \"AG\" can be extended left into \"TAG\", the first and third occurrences differ on both sides of the repeat; thus, we conclude that \"AG\" is a maximal repeat. Note that \"TAG\" is also a maximal repeat of \"TAGTTAGCGAGA\", since its only two occurrences do not still match if we extend them in either direction.\nGiven: A DNA string s of length at most 1 kbp.\nReturn: A list containing all maximal repeats of s having length at least 20.\nHow can we use the suffix tree of s to find maximal repeats?\n",
    "data": "TAGAGATAGAATGGGTCCAGAGTTTTGTAATTTCCATGGGTCCAGAGTTTTGTAATTTATTATATAGAGATAGAATGGGTCCAGAGTTTTGTAATTTCCATGGGTCCAGAGTTTTGTAATTTAT",
    "output": "TAGAGATAGAATGGGTCCAGAGTTTTGTAATTTCCATGGGTCCAGAGTTTTGTAATTTAT\nATGGGTCCAGAGTTTTGTAATTT",
    "topics": "Graph Algorithms, String Algorithms"
  },
  "('85', 'MULT')": {
    "className": "Problem",
    "moduleName": "model.Problem",
    "num": 85,
    "id": "MULT",
    "title": "Multiple Alignment",
    "body": "A multiple alignment of a collection of three or more strings is formed by adding gap symbols to the strings to produce a collection of augmented strings all having the same length.\nA multiple alignment score is obtained by taking the sum of an alignment score over all possible pairs of augmented strings.  The only difference in scoring the alignment of two strings is that two gap symbols may be aligned for a given pair (requiring us to specify a score for matched gap symbols).\nGiven: A collection of four DNA strings of length at most 10 bp in FASTA format.\nReturn: A multiple alignment of the strings having maximum score, where we score matched symbols 0 (including matched gap symbols) and all mismatched symbols -1 (thus incorporating a linear gap penalty of 1).\n",
    "data": ">Rosalind_7\nATATCCG\n>Rosalind_35\nTCCG\n>Rosalind_23\nATGTACTG\n>Rosalind_44\nATGTCTG",
    "output": "-18\nATAT-CCG\n-T---CCG\nATGTACTG\nATGT-CTG",
    "topics": "Alignment, Dynamic Programming"
  },
  "('86', 'PDPL')": {
    "className": "Problem",
    "moduleName": "model.Problem",
    "num": 86,
    "id": "PDPL",
    "title": "Creating a Restriction Map",
    "body": "For a set X containing numbers, the difference multiset of X is the multiset \\Delta X defined as the collection of all positive differences between elements of X. As a quick example, if X =\\{2, 4, 7\\}, then we will have that \\Delta X = \\{2, 3, 5\\}.\nIf X contains n elements, then \\Delta X will contain one element for each pair of elements from X, so that \\Delta X contains \\binom{n}{2} elements (see combination statistic). You may note the similarity between the difference multiset and the Minkowski difference X \\ominus X, which contains the elements of \\Delta X and their negatives. For the above set X, X \\ominus X is \\{-5, -3, -2, 2, 3, 5\\}.\nIn practical terms, we can easily obtain a multiset L corresponding to the distances between restriction sites on a chromosome. If we can find a set X whose difference multiset \\Delta X is equal to L, then X will represent possible locations of these restriction sites.  For an example, consult Figure 1.\nGiven: A multiset L containing \\binom{n}{2} positive integers for some positive integer n.\nReturn: A set X containing n nonnegative integers such that \\Delta X = L.\n",
    "data": "2 2 3 3 4 5 6 7 8 10",
    "output": "0 2 4 7 10",
    "topics": "Set Theory"
  },
  "('87', 'ROOT')": {
    "className": "Problem",
    "moduleName": "model.Problem",
    "num": 87,
    "id": "ROOT",
    "title": "Counting Rooted Binary Trees",
    "body": "As in the case of unrooted trees, say that we have a fixed collection of n taxa labeling the leaves of a rooted binary tree T.  You may like to verify that (by extension of \u201cCounting Phylogenetic Ancestors\u201d) such a tree will contain n-1 internal nodes and 2n-2 total edges. Any edge will still encode a split of taxa; however, the two splits corresponding to the edges incident to the root of T will be equal. We still consider two trees to be equivalent if they have the same splits (which requires that they must also share the same duplicated split to be equal).\nLet B(n) represent the total number of distinct rooted binary trees on n labeled taxa.\nGiven: A positive integer n (n \\leq 1000).\nReturn: The value of B(n) modulo 1,000,000.\n",
    "data": "4",
    "output": "15",
    "topics": "Combinatorics, Phylogeny"
  },
  "('88', 'SEXL')": {
    "className": "Problem",
    "moduleName": "model.Problem",
    "num": 88,
    "id": "SEXL",
    "title": "Sex-Linked Inheritance",
    "body": "The conditional probability of an event A given another event B, written \\mathrm{Pr}(A \\mid B), is equal to \\mathrm{Pr}(A \\textrm{ and } B) divided by \\mathrm{Pr}(B).\nNote that if A and B are independent, then \\mathrm{Pr}(A \\textrm{ and } B) must be equal to \\mathrm{Pr}(A) \\times \\mathrm{Pr}(B), which results in \\mathrm{Pr}(A \\mid B) = \\mathrm{Pr}(A). This equation offers an intuitive view of independence: the probability of A, given the occurrence of event B, is simply the probability of A (which does not depend on B).\nIn the context of sex-linked traits, genetic equilibrium requires that the alleles for a gene k are uniformly distributed over the males and females of a population. In other words, the distribution of alleles is independent of sex.\nGiven: An array A of length n for which A[k] represents the proportion of males in a population exhibiting the k-th of n total recessive X-linked genes. Assume that the population is in genetic equilibrium for all n genes.\nReturn: An array B of length n in which B[k] equals the probability that a randomly selected female will be a carrier for the k-th gene.\n",
    "data": "0.1 0.5 0.8",
    "output": "0.18 0.5 0.32",
    "topics": "Heredity, Probability"
  },
  "('89', 'SPTD')": {
    "className": "Problem",
    "moduleName": "model.Problem",
    "num": 89,
    "id": "SPTD",
    "title": "Phylogeny Comparison with Split Distance",
    "body": "Define the split distance between two unrooted binary trees as the number of nontrivial splits contained in one tree but not the other.\nFormally, if s(T_1, T_2) denotes the number of nontrivial splits shared by unrooted binary trees T_1 and T_2, Then their split distance is d_{\\textrm{split}}(T_1, T_2) = 2(n-3) - 2s(T_1, T_2).\nGiven: A collection of at most 3,000 species taxa and two unrooted binary trees T_1 and T_2 on these taxa in Newick format.\nReturn: The split distance d_{\\textrm{split}}(T_1, T_2).\n",
    "data": "dog rat elephant mouse cat rabbit\n(rat,(dog,cat),(rabbit,(elephant,mouse)));\n(rat,(cat,dog),(elephant,(mouse,rabbit)));",
    "output": "2",
    "topics": "Phylogeny"
  },
  "('90', 'WFMD')": {
    "className": "Problem",
    "moduleName": "model.Problem",
    "num": 90,
    "id": "WFMD",
    "title": "The Wright-Fisher Model of Genetic Drift",
    "body": "Consider flipping a weighted coin that gives \"heads\" with some fixed probability p (i.e., p is not necessarily equal to 1/2).\nWe generalize the notion of binomial random variable from \u201cIndependent Segregation of Chromosomes\u201d to quantify the sum of the weighted coin flips. Such a random variable X takes a value of k if a sequence of n independent \"weighted coin flips\" yields k \"heads\" and n-k \"tails.\"  We write that X \\in \\mathrm{Bin}(n, p).\nTo quantify the Wright-Fisher Model of genetic drift, consider a population of N diploid individuals, whose 2N chromosomes possess m copies of the dominant allele.  As in \u201cCounting Disease Carriers\u201d, set p = \\frac{m}{2N}. Next, recall that the next generation must contain exactly N individuals. These individuals' 2N alleles are selected independently: a dominant allele is chosen with probability p, and a recessive allele is chosen with probability 1-p.\nGiven: Positive integers N (N \\leq 7), m (m \\leq 2N), g (g \\leq 6) and k (k \\leq 2N).\nReturn: The probability that in a population of N diploid individuals initially possessing m copies of a dominant allele, we will observe after g generations at least k copies of a recessive allele. Assume the Wright-Fisher model.\n",
    "data": "4 6 2 1",
    "output": "0.772",
    "topics": "Population Dynamics, Probability"
  },
  "('91', 'ALPH')": {
    "className": "Problem",
    "moduleName": "model.Problem",
    "num": 91,
    "id": "ALPH",
    "title": "Alignment-Based Phylogeny",
    "body": "Say that we have n taxa represented by strings s_1, s_2, \\ldots, s_n with a multiple alignment inducing corresponding augmented strings \\overline{s}_1, \\overline{s}_2, \\ldots, \\overline{s}_n.\nRecall that the number of single-symbol substitutions required to transform one string into another is the Hamming distance between the strings (see \u201cCounting Point Mutations\u201d).  Say that we have a rooted binary tree T containing \\overline{s}_1, \\overline{s}_2, \\ldots, \\overline{s}_n at its leaves and additional strings \\overline{s}_{n+1}, \\overline{s}_{n+2}, \\ldots, \\overline{s}_{2n-1} at its internal nodes, including the root (the number of internal nodes is n-1 by extension of \u201cCounting Phylogenetic Ancestors\u201d). Define d_{\\textrm{H}}(T) as the sum of d_{\\textrm{H}}(\\overline{s}_i, \\overline{s}_j) over all edges \\{\\overline{s}_i, \\overline{s}_j\\} in T:\nd_{\\textrm{H}}(T) = \\sum\\limits_{\\{\\overline{s}_i, \\overline{s}_j\\} \\in E(T)}{d_{\\textrm{H}}(\\overline{s}_i, \\overline{s}_j)}\nThus, our aim is to minimize d_{\\textrm{H}}(T).\nGiven: A rooted binary tree T on n (n \\leq 500) species, given in Newick format, followed by a multiple alignment of m (m \\leq n) augmented DNA strings having the same length (at most 300 bp) corresponding to the species and given in FASTA format.\nReturn: The minimum possible value of d_{\\textrm{H}}(T), followed by a collection of DNA strings to be assigned to the internal nodes of T that will minimize d_{\\textrm{H}}(T) (multiple solutions will exist, but you need only output one).\nGiven internal strings minimizing d_{\\textrm{H}}(T), the alignment between any two adjacent strings is not necessarily an optimal global paired alignment.  In other words, it may not be the case that d_{\\textrm{H}}(\\overline{s}_i, \\overline{s}_j) is equal to the edit distance d_{\\textrm{E}}(s_i, s_j).\n",
    "data": "(((ostrich,cat)rat,(duck,fly)mouse)dog,(elephant,pikachu)hamster)robot;\n>ostrich\nAC\n>cat\nCA\n>duck\nT-\n>fly\nGC\n>elephant\n-T\n>pikachu\nAA",
    "output": "8\n>rat\nAC\n>mouse\nTC\n>dog\nAC\n>hamster\nAT\n>robot\nAC",
    "topics": "Phylogeny"
  },
  "('92', 'ASMQ')": {
    "className": "Problem",
    "moduleName": "model.Problem",
    "num": 92,
    "id": "ASMQ",
    "title": "Assessing Assembly Quality with N50 and N75",
    "body": "Given a collection of DNA strings representing contigs, we use the N statistic NXX (where XX ranges from 01 to 99) to represent the maximum positive integer L such that the total number of nucleotides of all contigs having length \\ge L is at least XX% of the sum of contig lengths.  The most commonly used such statistic is N50, although N75 is also worth mentioning.\nGiven: A collection of at most 1000 DNA strings (whose combined length does not exceed 50 kbp).\nReturn: N50 and N75 for this collection of strings.\nFor an explanation of the results obtained in the sample above, contigs of length at least 7 total 7 + 9 = 16 bp, which is more than 50% of the total 27). Contigs of length at least 8 total only 9 bp (less than 50%).\nContigs of length at least 6 total 6 + 7 + 9 = 22 bp, which is more than 75% of all base pairs. Contigs of length at least 7 total only 16 bp (less than 75%).\n",
    "data": "GATTACA\nTACTACTAC\nATTGAT\nGAAGA",
    "output": "7 6",
    "topics": "Genome Assembly"
  },
  "('93', 'CSET')": {
    "className": "Problem",
    "moduleName": "model.Problem",
    "num": 93,
    "id": "CSET",
    "title": "Fixing an Inconsistent Character Set",
    "body": "A submatrix of a matrix M is a matrix formed by selecting rows and columns from M and taking only those entries found at the intersections of the selected rows and columns.  We may also think of a submatrix as formed by deleting the remaining rows and columns from M.\nGiven: An inconsistent character table C on at most 100 taxa.\nReturn: A submatrix of C' representing a consistent character table on the same taxa and formed by deleting a single row of C. (If multiple solutions exist, you may return any one.)\n",
    "data": "100001\n000110\n111000\n100111",
    "output": "000110\n100001\n100111",
    "topics": "Phylogeny"
  },
  "('94', 'EBIN')": {
    "className": "Problem",
    "moduleName": "model.Problem",
    "num": 94,
    "id": "EBIN",
    "title": "Wright-Fisher's Expected Behavior",
    "body": "In \u201cThe Wright-Fisher Model of Genetic Drift\u201d, we generalized the concept of a binomial random variable \\mathrm{Bin}(n, p) as a \"weighted coin flip.\"  It is only natural to calculate the expected value of such a random variable.\nFor example, in the case of unweighted coin flips (i.e., p = 1/2), our intuition would indicate that \\mathrm{E}(\\mathrm{Bin}(n, 1/2)) is n/2; what should be the expected value of a binomial random variable?\nGiven: A positive integer n (n \\leq 1000000) followed by an array P of length m (m \\leq 20) containing numbers between 0 and 1.  Each element of P can be seen as representing a probability corresponding to an allele frequency.\nReturn: An array B of length m for which B[k] is the expected value of \\mathrm{Bin}(n, P[k]); in terms of Wright-Fisher, it represents the expected allele frequency of the next generation.\n",
    "data": "17\n0.1 0.2 0.3",
    "output": "1.7 3.4 5.1",
    "topics": "Probability"
  },
  "('95', 'FOUN')": {
    "className": "Problem",
    "moduleName": "model.Problem",
    "num": 95,
    "id": "FOUN",
    "title": "The Founder Effect and Genetic Drift",
    "body": "Given: Two positive integers N and m, followed by an array A containing k integers between 0 and 2N. A[j] represents the number of recessive alleles for the j-th factor in a population of N diploid individuals.\nReturn: An m \\times k matrix B for which B_{i, j} represents the common logarithm of the probability that after i generations, no copies of the recessive allele for the j-th factor will remain in the population. Apply the Wright-Fisher model.\n",
    "data": "4 3\n0 1 2",
    "output": "0.0 -0.463935575821 -0.999509892866\n0.0 -0.301424998891 -0.641668367342\n0.0 -0.229066698008 -0.485798552456",
    "topics": "Population Dynamics, Probability"
  },
  "('96', 'GAFF')": {
    "className": "Problem",
    "moduleName": "model.Problem",
    "num": 96,
    "id": "GAFF",
    "title": "Global Alignment with Scoring Matrix and Affine Gap Penalty",
    "body": "An affine gap penalty is written as a + b \\cdot (L-1), where L is the length of the gap, a is a positive constant called the gap opening penalty, and b is a positive constant called the gap extension penalty.\nWe can view the gap opening penalty as charging for the first gap symbol, and the gap extension penalty as charging for each subsequent symbol added to the gap.\nFor example, if a = 11 and b = 1, then a gap of length 1 would be penalized by 11 (for an average cost of 11 per gap symbol), whereas a gap of length 100 would have a score of 110 (for an average cost of 1.10 per gap symbol).\nConsider the strings \"PRTEINS\" and \"PRTWPSEIN\".  If we use the BLOSUM62 scoring matrix and an affine gap penalty with a = 11 and b = 1, then we obtain the following optimal alignment.\nMatched symbols contribute a total of 32 to the calculation of the alignment's score, and the gaps cost 13 and 11 respectively, yielding a total score of 8.\nGiven: Two protein strings s and t in FASTA format (each of length at most 100 aa).\nReturn: The maximum alignment score between s and t, followed by two augmented strings s' and t' representing an optimal alignment of s and t.  Use:\n",
    "data": ">Rosalind_49\nPRTEINS\n>Rosalind_47\nPRTWPSEIN",
    "output": "8\nPRT---EINS\nPRTWPSEIN-",
    "topics": "Alignment, Dynamic Programming"
  },
  "('97', 'GREP')": {
    "className": "Problem",
    "moduleName": "model.Problem",
    "num": 97,
    "id": "GREP",
    "title": "Genome Assembly with Perfect Coverage and Repeats",
    "body": "Recall that a directed cycle is a cycle in a directed graph in which the head of one edge is equal to the tail of the following edge.\nIn a de Bruijn graph of k-mers, a circular string s is constructed from a directed cycle s_1 \\rightarrow s_2 \\rightarrow ... \\rightarrow s_i \\rightarrow s_1 is given by s_1 + s_2[k] +  ... + s_{i-k}[k]  + s_{i-k+1}[k]. That is, because the final k-1 symbols of s_1 overlap with the first k-1 symbols of s_2, we simply tack on the k-th symbol of s_2 to s, then iterate the process.\nFor example, the circular string assembled from the cycle \"AC\" \\rightarrow \"CT\" \\rightarrow \"TA\" \\rightarrow \"AC\" is simply (ACT).  Note that this string only has length three because the 2-mers \"wrap around\" in the string.\nIf every k-mer in a collection of reads occurs as an edge in a de Bruijn graph cycle the same number of times as it appears in the reads, then we say that the cycle is \"complete.\"\nGiven: A list S_{k+1} of error-free DNA (k+1)-mers (k \\leq 5) taken from the same strand of a circular chromosome (of length \\leq 50).\nReturn: All circular strings assembled by complete cycles in the de Bruijn graph B_k of S_{k+1}. The strings may be given in any order, but each one should begin with the first (k+1)-mer provided in the input.\n",
    "data": "CAG\nAGT\nGTT\nTTT\nTTG\nTGG\nGGC\nGCG\nCGT\nGTT\nTTC\nTCA\nCAA\nAAT\nATT\nTTC\nTCA",
    "output": "CAGTTCAATTTGGCGTT\nCAGTTCAATTGGCGTTT\nCAGTTTCAATTGGCGTT\nCAGTTTGGCGTTCAATT\nCAGTTGGCGTTCAATTT\nCAGTTGGCGTTTCAATT",
    "topics": "Genome Assembly, Graph Algorithms"
  },
  "('98', 'OAP')": {
    "className": "Problem",
    "moduleName": "model.Problem",
    "num": 98,
    "id": "OAP",
    "title": "Overlap Alignment",
    "body": "An overlap alignment between two strings s and t is a local alignment of a suffix of s with a prefix of t.  An optimal overlap alignment will therefore maximize an alignment score over all such substrings of s and t.\nThe term \"overlap alignment\" has also been used to describe what Rosalind defines as a semiglobal alignment.  See \u201cSemiglobal Alignment\u201d for details.\nGiven: Two DNA strings s and t in FASTA format, each having length at most 10 kbp.\nReturn: The score of an optimal overlap alignment of s and t, followed by an alignment of a suffix s' of s and a prefix t' of t achieving this optimal score. Use an alignment score in which matching symbols count +1, substitutions count -2, and there is a linear gap penalty of 2.  If multiple optimal alignments exist, then you may return any one.\nThis problem follows Jones & Pevzner, An Introduction to Bioinformatics Algorithms, problem 6.22.\n",
    "data": ">Rosalind_54\nCTAAGGGATTCCGGTAATTAGACAG\n>Rosalind_45\nATAGACCATATGTCAGTGACTGTGTAA",
    "output": "1\nATTAGAC-AG\nAT-AGACCAT",
    "topics": "Alignment, Dynamic Programming"
  },
  "('99', 'QRTD')": {
    "className": "Problem",
    "moduleName": "model.Problem",
    "num": 99,
    "id": "QRTD",
    "title": "Quartet Distance",
    "body": "In \u201cCounting Quartets\u201d, we found an expression for q(T), the number of quartets that can be inferred from an unrooted binary tree containing n taxa.\nIf T_1 and T_2 are both unrooted binary trees on the same n taxa, then we now let q(T_1, T_2) denote the number of inferred quartets that are common to both trees. The quartet distance between T_1 and T_2, d_{\\textrm{q}}(T_1, T_2) is the number of quartets that are only inferred from one of the trees.  More precisely, d_\\textrm{q}(T_1, T_2) = q(T_1) + q(T_2) - 2q(T_1, T_2).\nGiven: A list containing n taxa (n \\leq 2000) and two unrooted binary trees T_1 and T_2 on the given taxa.  Both T_1 and T_2 are given in Newick format.\nReturn: The quartet distance d_\\textrm{q}(T_1, T_2).\n",
    "data": "A B C D E\n(A,C,((B,D),E));\n(C,(B,D),(A,E));",
    "output": "4",
    "topics": "Phylogeny"
  },
  "('100', 'SIMS')": {
    "className": "Problem",
    "moduleName": "model.Problem",
    "num": 100,
    "id": "SIMS",
    "title": "Finding a Motif with Modifications",
    "body": "Given a string s and a motif t, an alignment of a substring of s against all of t is called a fitting alignment.  Our aim is to find a substring s' of s that maximizes an alignment score with respect to t.\nNote that more than one such substring of s may exist, depending on the particular strings and alignment score used.  One candidate for scoring function is the one derived from edit distance; In this problem, we will consider a slightly different alignment score, in which all matched symbols count as +1 and all mismatched symbols (including insertions and deletions) receive a cost of -1. Let's call this scoring function the mismatch score. See Figure 1 for a comparison of global, local, and fitting alignments with respect to mismatch score.\nGiven: Two DNA strings s and t, where s has length at most 10 kbp and t represents a motif of length at most 1 kbp.\nReturn: An optimal fitting alignment score with respect to the mismatch score defined above, followed by an optimal fitting alignment of a substring of s against t. If multiple such alignments exist, then you may output any one.\nThis problem follows Jones & Pevzner, An Introduction to Bioinformatics Algorithms, Problem 6.23.\n",
    "data": ">Rosalind_54\nGCAAACCATAAGCCCTACGTGCCGCCTGTTTAAACTCGCGAACTGAATCTTCTGCTTCACGGTGAAAGTACCACAATGGTATCACACCCCAAGGAAAC\n>Rosalind_46\nGCCGTCAGGCTGGTGTCCG",
    "output": "5\nACCATAAGCCCTACGTG-CCG\nGCCGTCAGGC-TG-GTGTCCG",
    "topics": null
  },
  "('101', 'SMGB')": {
    "className": "Problem",
    "moduleName": "model.Problem",
    "num": 101,
    "id": "SMGB",
    "title": "Semiglobal Alignment",
    "body": "A semiglobal alignment of strings s and t is an alignment in which any gaps appearing as prefixes or suffixes of s and t do not contribute to the alignment score.\nSemiglobal alignment has sometimes also been called \"overlap alignment\".  Rosalind defines overlap alignment differently (see \u201cOverlap Alignment\u201d).\nGiven: Two DNA strings s and t in FASTA format, each having length at most 10 kbp.\nReturn: The maximum semiglobal alignment score of s and t, followed by an alignment of s and t achieving this maximum score.  Use an alignment score in which matching symbols count +1, substitutions count -1, and there is a linear gap penalty of 1. If multiple optimal alignments exist, then you may return any one.\nThis problem follows Jones & Pevzner, An Introduction to Bioinformatics Algorithms, Problem 6.24.\n",
    "data": ">Rosalind_79\nCAGCACTTGGATTCTCGG\n>Rosalind_98\nCAGCGTGG",
    "output": "4\nCAGCA-CTTGGATTCTCGG\n---CAGCGTGG--------",
    "topics": "Alignment, Dynamic Programming"
  },
  "('102', 'KSIM')": {
    "className": "Problem",
    "moduleName": "model.Problem",
    "num": 102,
    "id": "KSIM",
    "title": "Finding All Similar Motifs",
    "body": "Given: A positive integer k (k \\leq 50), a DNA string s of length at most 5 kbp representing a motif, and a DNA string t of length at most 50 kbp representing a genome.\nReturn: All substrings t' of t such that the edit distance d_{\\mathrm{E}}(s, t') is less than or equal to k.  Each substring should be encoded by a pair containing its location in t followed by its length.\n",
    "data": "2\nACGTAG\nACGGATCGGCATCGT",
    "output": "1 4\n1 5\n1 6",
    "topics": "String Algorithms"
  },
  "('103', 'LAFF')": {
    "className": "Problem",
    "moduleName": "model.Problem",
    "num": 103,
    "id": "LAFF",
    "title": "Local Alignment with Affine Gap Penalty",
    "body": "Given: Two protein strings s and t in FASTA format (each having length at most 10,000 aa).\nReturn: The maximum local alignment score of s and t, followed by substrings r and u of s and t, respectively, that correspond to the optimal local alignment of s and t. Use:\nIf multiple solutions exist, then you may output any one.\n",
    "data": ">Rosalind_8\nPLEASANTLY\n>Rosalind_18\nMEANLY",
    "output": "12\nLEAS\nMEAN",
    "topics": "Alignment, Dynamic Programming"
  },
  "('104', 'OSYM')": {
    "className": "Problem",
    "moduleName": "model.Problem",
    "num": 104,
    "id": "OSYM",
    "title": "Isolating Symbols in Alignments",
    "body": "Say that we have two strings s and t of respective lengths m and n and an alignment score. Let's define a matrix \\mathrm{M} corresponding to s and t by setting \\mathrm{M}_{j, k} equal to the maximum score of any alignment that aligns s[j] with t[k]. So each entry in \\mathrm{M} can be equal to at most the maximum score of any alignment of s and t.\nGiven: Two DNA strings s and t in FASTA format, each having length at most 1000 bp.\nReturn: The maximum alignment score of a global alignment of s and t, followed by the sum of all elements of the matrix \\mathrm{M} corresponding to s and t that was defined above.  Apply the mismatch score introduced in \u201cFinding a Motif with Modifications\u201d.\nThis problem follows Jones & Pevzner, An Introduction to Bioinformatics Algorithms, Problem 6.21\nFor the sample dataset   \\mathrm{M} =  \\begin{bmatrix}  3  &  0 &-1 &-4 &-5 &-10 &-11\\\\  0  &  3 & 0 &-1 &-4 & -7 &-10\\\\ -1  &  0 & 3 &-2 &-1 & -6 & -7\\\\ -4  & -1 & 0 & 3 & 0 & -3 & -6\\\\ -7  & -4 &-3 & 2 & 3 &  0 & -3\\\\ -10 & -5 &-6 &-3 & 0 &  3 & -2\\\\ -11 &-10 &-5 &-6 &-1 & -2 &  3  \\end{bmatrix}\n",
    "data": ">Rosalind_35\nATAGATA\n>Rosalind_5\nACAGGTA",
    "output": "3\n-139",
    "topics": "Alignment, Dynamic Programming"
  },
  "('105', 'RSUB')": {
    "className": "Problem",
    "moduleName": "model.Problem",
    "num": 105,
    "id": "RSUB",
    "title": "Identifying Reversing Substitutions",
    "body": "For a rooted tree T whose internal nodes are labeled with genetic strings, our goal is to identify reversing substitutions in T.  Assuming that all the strings of T have the same length, a reversing substitution is defined formally as two parent-child string pairs (s, t) and (v, w) along with a position index i, where:\nIn other words, the third condition demands that a reversing substitution must be contiguous: no other substitutions can appear between the initial and reversing substitution.\nGiven: A rooted binary tree T with labeled nodes in Newick format, followed by a collection of at most 100 DNA strings in FASTA format whose labels correspond to the labels of T. We will assume that the DNA strings have the same length, which does not exceed 400 bp).\nReturn: A list of all reversing substitutions in T (in any order), with each substitution encoded by the following three items:\n",
    "data": "(((ostrich,cat)rat,mouse)dog,elephant)robot;\n>robot\nAATTG\n>dog\nGGGCA\n>mouse\nAAGAC\n>rat\nGTTGT\n>cat\nGAGGC\n>ostrich\nGTGTC\n>elephant\nAATTC",
    "output": "dog mouse 1 A->G->A\ndog mouse 2 A->G->A\nrat ostrich 3 G->T->G\nrat cat 3 G->T->G\ndog rat 3 T->G->T",
    "topics": "Phylogeny"
  }
}
